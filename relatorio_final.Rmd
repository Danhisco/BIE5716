---
title: "Generalization of the stochastic logistic model to interspecific competition"
author: "Danilo Pereira Mori"
date: "2022-08-20"
output: html_document
editor_options: 
  chunk_output_type: inline
bibliography: citations.bib
csl: plos.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,message = FALSE,warning = FALSE,cache = TRUE)
```

```{r pacotes, include=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
library(trackdown)
library(knitr)
library(kableExtra)
library(bbmle)
library(MuMIn)
library(AICcmodavg)
library(boot)
library(DHARMa)
library(lme4)
library(gridExtra)
library(deSolve)
library(doMC)
library(plyr)
library(tidyverse)
```



```{r google docs management, eval=FALSE,include=FALSE}
# library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
update_file(file ="relatorio_final.Rmd",
            gpath = "mestrado/disciplinas/BIE5716/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file ="relatorio_final.Rmd",
              gpath = "mestrado/disciplinas/BIE5716/")
```

### Introdução  
   
<p>O modelo de crescimento exponencial incorpora o princípio fundamental de que a vida provém de outra e assim examina o comportamento de uma população que pode crescer sem limitação alguma. Ao incluir a influência que o aumento na densidade populacional pode ter na limitação do crescimento, o modelo logístico incorpora outro princípio fundamental que é o da perda de excedente de indivíduos esperado por um crescimento ilimitado. Caso uma população crescesse de forma exponencial todo o universo conhecido poderia estar colonizado por um único tipo de vida. Outro componente essencial da modulação dos eventos demográficos é a interação com outras espécies, como competição interespecífica. </p>
<p>Os modelos de competição de populações em denso dependência do arcabouço de reações de difusão (estocásticos) diferem dos modelos baseados em taxas constantes (determinísticos), pois os eventos demográficos são representados como eventos probabilísticos que podem ou não ocorrer em intervalos de tempo muito pequenos. Dessa forma, os modelos estocásticos possibilitam eventos de extinção de populações que poderiam permanecer indefinidamente no predito determinístico; ou flutuações nos tamanhos populacionais, propriedade ausente nos modelos determinísticos de denso dependência linear. Os modelos estocásticos podem ser descritos por uma equação mestra, um conjunto de equações diferenciais de primeira ordem que descrevem como a probabilidade de todos os possíveis estados do sistema varia no tempo contínuo. A partir da equação mestra é possível calcular a equação diferencial do primeiro momento da distribuição de probabilidades do sistema. Usando a aproximação de campo médio, onde é pressuposto variância zero, a equação diferencial do primeiro momento converge para a solução determinística. Alternativamente à descrição de todos os estados do sistema, é possível simular trajetórias individuais no sistema com o algoritmo de Gillespie [@Gillespie1977], onde podemos acompanhar a trajetória da abundância de cada espécie até a extinção.</p>
<p>Aqui vamos explorar a competição de 2 populações em crescimento denso dependente, N e M, em cenários de invasão da espécie M no sistema dominado por N que se encontra em sua capacidade de suporte. Usando modelos estocásticos e a aproximação de campo médio, explorei cenários de assimetria competitiva e de tamanho inicial da espécie invasora. Me pergunto a) Como a probabilidade de substituição da espécie residente pela invasora varia com o tamanho populacional inicial da invasora e da assimetria competitiva? e b) Como a presença da espécie residente reduz o tempo de extinção da espécie invasora?</p>

### Métodos
    
#### Reações  
  
<p>Vamos modelar a mudança de estado do sistema, descrito por (n,m), onde n e m são a abundância de N e M, respectivamente. O modelo considera possíveis mudanças discretas de 1 indivíduo no sistema em um intervalo de tempo muito pequeno dt. As oito reações consideradas estão disponíveis na tabela 1, elas constituem um modelo de denso dependência em que a competição interespecífica é modelada de forma similar à da competição intraespecífica: pela probabilidade de exclusão de um dos dois indivíduos por evento de colisão de dois indivíduos. O modelo pressupõe que não é possível distinguir entre indivíduos de uma mesma espécie, assim, o parâmetro $\gamma$ descreve a probabilidade de qualquer um dos dois indivíduos ser excluído, por isso ele está dividido por 2.</p>

```{r tabela 1}
df_tabela1 <- data.frame(reactions = c("n -> n + n","n -> 0","n + n -> n","n + m -> m",
                                       "m -> m + m","m -> 0","m + m -> m","m + n -> n"),
                         description = c("reprod. assex. de N","morte de N","comp. intraesp. de N","exclusão de N por M",
                                         "reprod. assex. de M","morte de M","comp. intraesp. de M","exclusão de M por N"),
                         Prob_dt = c("$\\beta n$","$\\delta n$","$\\gamma n (n-1) 2^{-1}$","$\\text{C}_{n} n m$",
                                     "$\\beta m$","$\\delta m$","$\\gamma m (m-1) 2^{-1}$","$\\text{C}_{m} m n$"),
                         unit_ParDemog = c("$P(nasc. de N)/ind. de N  dt$", "$P(morte de N)/ind. de N dt$",
                                           "$P(exclusão de N)/colisão N dt$","$P(exclusão de N)/colisão N M dt$",
                                           "$P(nasc. de M)/ind. de M dt$", "$P(morte de M)/ind. de M dt$",
                                           "$P(exclusão de M)/colisão M dt$","$P(exclusão de M)/colisão M N dt$"))
df_tabela1 %>%
  kbl(caption = "Tabela 1. Possíveis reações no modelo estocástico de competição de duas espécies sob denso dependência",
      col.names = c("reações","descrição","taxa","unidade do parâmetro")) %>%
  kable_classic(full_width = T, html_font = "Cambria")

```
  
#### The master equation and the mean-field approximation      
     
<p>A partir das reações é possível desenvolver uma equação mestra que descreve a taxa de mudança da probabilidade de um determinado estado [$\frac{\partial P(n,m,t)}{\partial t}$] pela diferença na taxa da probabilidade de entrada e saída deste estado (equação 1). Na primeira linha depois da igualdade, há a soma das taxa com que N pode perder um indivíduo, indo do estado (n+1,m) para o estado (n,m). Na segunda linha a taxa com que N pode ganhar um indivíduo, indo do estado (n-1,m) para o estado (n,m). Nas linhas 3 e 4 a mesma lógica para M. Na quinta linha há a taxa de saída do estado (n,m). Para detalhes veja tabela 1.</p>

\begin{equation}\label{eqn: 1}
\frac{\partial P(n,m,t)}{\partial t} = \\
P(n+1,m) (n+1) (\delta_n + n \gamma_n / 2 + m C_{n}) +\\ P(n-1,m) (n-1) \beta_n+\\ 
P(n,m+1) (m+1) (\delta_m + m \gamma_m / 2 + n C_{m}) +\\ P(n,m-1) (m-1) \beta_m+\\
- P(n,m)[n(\beta_n + \delta_n + (n-1) \gamma_n / 2 + m C_{n}) + m(\beta_m + \delta_m + (m-1) \gamma_m / 2 + n C_{m})]
\end{equation}

<p>Na aproximação de campo médio buscamos obter o primeiro momento da distribuição de probabilidade marginal de N, E[N] = <n>, e de M, E[M] = <m>. Para isso é necessário estabelecer algumas definições: $<n> = \sum_{n=0}^{\infty} n P(n,m,t)$; $<n^2> = \sum_{n=0}^{\infty} n^2 P(n,m,t)$; $<m> = \sum_{m=0}^{\infty} m P(n,m,t)$; $<m^2> = \sum_{m=0}^{\infty} m^2 P(n,m,t)$; $<nm> = \sum_{n=0}^{\infty}\sum_{m=0}^{\infty} nm P(n,m,t)$. Para obter o primeiro momento marginal de N ou M basta multiplicar a equação mestra por n ou m e realizar o somatório (apêndice 1), e então é possível obter as equações 2a e 2b:</p>

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n^2>\gamma_n2^{-1} - <nm>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m^2>\gamma_m2^{-1} - <mn>C_m
$$

<p>A aproximação de campo médio pressupõe que $<n>^2 = <n^2>$, $<m>^2 = <m^2>$, $<nm> = <n><m>$. Esse pressuposto implica que a variância da dinâmica populacional denso dependente é zero e que as populações são independentes. Outro pressuposto possível para simplificar a aproximação é de que $\beta$ ou $\delta$ >> $\gamma$, assim $\gamma$ pode ser omitido como fator do primeiro momento. Essa aproximação é útil pois permite a convergência das equações acima com o modelo determinístico de competição interespecífica de duas populações com crescimento denso dependente (eq. 3a e 3b). </p>

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n)- <n>^2\gamma_n2^{-1} - <n><m>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m)- <m>^2\gamma_m2^{-1} - <m><n>C_m
$$
<p> A investigação desse modelo determinístico no equilíbrio mostra o quê poderíamos esperar no longo prazo caso não houvesse nenhuma flutuação devido à estocástica dos eventos demográficos. No espaço de fase definido pela abundância da espécie residente, no eixo x, e da invasora, eixo y, a isolinha descreve as combinações de tamanhos populacionais onde o crescimento populacional da espécie focal é zero. Para explorar os cenários determinísticos no equilíbrio é possível expressar as duas isolinhas em função da abundância da invasora (eq. 4a e 4b e figura 1).</p>

$$
<m> = \frac{\beta_n - \delta_n}{C_n} - \frac{<n'>\gamma_n}{2C_n} 
$$
$$
<m'> = \frac{2(\beta_m - \delta_m)}{\gamma_m} - \frac{2C_m<n>}{\gamma_m} 
$$

#### The computational model
´
<p>A ideia do algoritmo de Gillespie [@Gillespie1977] se baseia no fato de que a distribuição de tempos entre mudanças de estados pode ser descrita por uma distribuição exponencial, então computamos separadamente as mudanças de estado e o tempo entre mudanças, reduzindo o tempo de simulação.  O tempo entre mudança de estados pode ser obtido pela divisão do log de uma amostra de distribuição uniforme padrão pela soma das taxas de saída do estado (janela de código 1). Existem 4 possíveis transições de estado: cada uma das duas espécies pode ganhar ou perder um indivíduo por evento demográfico no intervalo de tempo dt. A taxa de ganho de um indivíduo de N ($n\_p$) é  $n\_p=\beta n$. A taxa de perda de um indivíduo de N ($n\_m$) é $n\_m = n[\delta +(n-1)\gamma2^{-1} + mC_n]$. A mesma lógica se aplica para as taxas de ganho e perda da espécie M (eq. 1 e janela de código 1). Após o sorteio do tempo do próximo evento demográfico, é feito um sorteio da mudança de estado com probabilidade dada pela contribuição relativa de cada taxa de saída (janela de código 1), então o sistema é atualizado. Nossa simulação termina quando a espécie invasora atinge a abundância zero.</p>

__janela de código 1__

```{r the computacional model,echo=TRUE,eval=TRUE}
f_2sppSLV <- function(N0,beta_n,delta_n,gamma_n,C_n,
                      M0,beta_m,delta_m,gamma_m,C_m,
                      replicas,path_csv){
 df_ab <- data.frame(n=N0,m=M0,t=0)
 df_t <- data.frame(n=c(1,-1,0,0), # 4 possibles transitions:
                    m=c(0,0,1,-1)) # n + 1, n - 1, m + 1, m - 1
 f_loop <- function(){
   while(df_ab[nrow(df_ab),"m"] !=0){
   v_rates <- c( 
     n_p = df_ab[nrow(df_ab),"n"] * beta_n,     # n+1
     n_m = df_ab[nrow(df_ab),"n"] * (delta_n +  # n-1
                                       (df_ab[nrow(df_ab),"n"]-1) * gamma_n/2 +
                                       C_n * df_ab[nrow(df_ab),"m"]),
     m_p = df_ab[nrow(df_ab),"m"] * beta_m,     # m+1
     m_m = df_ab[nrow(df_ab),"m"] *(delta_m +   # m-1
                                      (df_ab[nrow(df_ab),"m"]-1) * gamma_m/2 +  
                                      C_m * df_ab[nrow(df_ab),"n"]))
   v_Srates <- sum(v_rates)
   # update
   df_ab[nrow(df_ab)+1,] <- c(df_ab[nrow(df_ab),1:2] + df_t[sample(1:4,size = 1,prob=v_rates/v_Srates),],
                              df_ab[nrow(df_ab),"t"] - log(runif(1))/v_Srates)
   }
   return(df_ab)
}
df_dinamica <- plyr::rdply(.n = replicas,f_loop())
readr::write_csv(df_dinamica,file = path_csv)
}
```
  

#### Cenários de assimetria competitiva e tamanho inicial da invasora
  
<p>Apenas o parâmetro que descreve a probabilidade de exclusão de uma espécie pela outra por colisão (parâmetros $C_n$ e $C_m$, tabela 1) variou entre simulações. Os demais parâmetros populacionais foram iguais: $\beta =$ `r format(0.7/365.25,scientific = TRUE,digits = 4)`, $\delta =$ `r format(0.69/365.25,scientific = TRUE,digits = 4)`, $\gamma =$ `r format(2*(0.7/365.25-0.69/365.25)/50,scientific = TRUE,digits = 4)`. Os parâmetros de competição interespecífica ($C_n$ e $C_m$) variam entre $\gamma/4$ e $\gamma/2$, tal que a assimetria competitiva, definido por $2(C_n - C_m)/ \gamma$, variou entre -0.5 e 0.5 (figura 1). O tamanho inicial da espécie invasora variou entre 1% e 100% da capacidade de suporte K = 50 indivíduos (Figura 1a). Foram simulados 11 cenários de tamanho inicial da invasora e 11 cenários de assimetria competitiva, totalizando 121 cenários, cada um com 100 réplicas. Quando a assimetria é nula então o sistema é indeterminado; se ela for maior do que zero então, dado tempo suficiente, a espécie invasora irá dominar o sistema; se a assimetria é negativa, então a residente dominará o sistema (Figura 1b) </p> 




```{r graficos dos cenarios simulados, echo=FALSE,eval=TRUE,fig.width=8,fig.height=4}
# dados completo
df_sim0 <- data.frame(k = 50, beta = 0.7/365.25, delta = 0.69/365.25) |> 
  mutate(gamma = 2 * (beta - delta) / k)
df_sim0 <- cbind(df_sim0,
                 expand.grid(M0 = floor(df_sim0$k * c(0.05,seq(0.1,1,by=0.1))),
                             C_n = (df_sim0$gamma/2) * seq(0.50,1,length.out=6))) |> 
  mutate(C_m = gamma/2)
df_sim0 <- rbind(filter(df_sim0,C_n!=(df_sim0$gamma[1]/2)),
                 mutate(df_sim0,
                        C_m=C_n,C_n=gamma/2)) |> 
  mutate(C_nm = ((C_n - C_m)*2)/gamma) %>% 
  arrange(M0,C_nm) %>% 
  dplyr::mutate(id = 1:n(),
         path = paste0("csv/md_Estocastico/id_",id,".csv"))
write_csv(df_sim0,file = "csv/df_sim0.csv")
df_sim0 <- df_sim0 |> 
  select(-path)
# gráficos
## cenários simluados
df_sim0 |> 
  mutate(M0_plot = M0/50) |> 
  ggplot(aes(x=M0_plot,y=C_nm)) + 
  geom_hline(yintercept = 0,color="red",alpha=0.4) +
  geom_point() +
  labs(title = "a) Cenários Simulados",
       x="initial abundance m (%K = 50)",y=expression((C[n] - C[m])*2/gamma),
       subtitle = "n = resident specie, m = invader specie") +
  theme_bw()
## isolinhas das espécies no espaço de fase definido por elas
df_plot <- df_sim0 |> filter(C_nm %in% c(-0.5,0,0.5) & M0==2) |>  select(-M0)
beta = df_sim0$beta[1]
delta = df_sim0$delta[1]
gamma = df_sim0$gamma[1]
# equação 4a
f_IsoResidente <- function(x,C_n) (beta - delta) / C_n - x * gamma/(2*C_n)
f_IsoInvasora <- function(x,C_m) 2*(beta - delta)/gamma - 2*C_m*x/gamma
# curve(f_IsoResidente(x,C_n=df_plot$C_n[1]),from = 0,to = 50)
df_plot <- left_join(x=data.frame(x=rep(0:50,3),id = rep(c(1,6,11),each=51)),
                     y=df_plot,
                     by="id") |> 
  select(-id,-k) |> 
  mutate(n = f_IsoResidente(x=x,C_n=C_n),
         m = f_IsoInvasora(x=x,C_m=C_m))
l_p[[2]] <- df_plot |> 
  pivot_longer(cols = c("n", "m"),
               names_to = "species",
               values_to = "N") |> 
  mutate(C_nm = factor(C_nm,levels = c(0.5,0,-0.5)),
         species = factor(species,levels = c("n","m"))) |>
  ggplot(aes(x=x,y=N,color=species)) +
  geom_line(alpha=0.5,size=1.2) + 
  ylim(0,50) + 
  xlim(0,50) +
  scale_color_manual(labels = c("n", "m"),
                     values = c("blue", "red")) +
  coord_cartesian(expand = FALSE) +
  labs(x="n",y="m",color="",title="b) Isolinhas Campo Médio") +
  theme_bw() + theme(legend.position="right") +
  facet_wrap(~C_nm,ncol=1)
grid.arrange(grobs=l_p,ncol=2,layout_matrix=matrix(c(1,1,1,1,2,2),nrow=1))
```
  
__Figura 1__ Cenários simulados de competição interespecífica (a) e as isolinhas obtidas na aproximação de campo médio na  plano de fase (b). a) Eixo y: assimetria competitiva -  a diferença no parâmetro C da espécie residente pela invasora, dividido pelo parâmetro $\gamma$. Eixo x: tamanhos iniciais da espécie invasora de 4% até 100%. b) O plano de fase é definido pelas possíveis abundâncias da espécie residente (eixo x) e da espécie invasora (y).
 



#### Análise dos dados

__Probabilidade de substituição da residente pela invasora__
<p> Para avaliar a probabilidade de substituição da espécie residente pela invasora, considerei a identidade da espécie que permanece após a primeira extinção. Se a espécie que permanece é a invasora então ocorreu um evento de substituição. Para descrever a probabilidade de substituição na simulação das trajetórias individuais usei um GLM binomial logito com o tamanho inicial da invasora e a assimetria competitiva como variáveis preditoras (detalhes no apêndice). Usei uma abordagem baseada em modelo médio [@Dormann2018], em que a partir de um modelo cheio é ajustado todos os possíveis submodelos e então a predição de cada modelo é ponderada pelo peso de evidência do submodelo. O GLM binomial cheio considerou a interação do polinômio de segundo grau de cada preditora; o tamanho populacional inicial da invasora pode ser usado na escala log.</p>

__Tempo de extinção da Invasora na presença e ausência da residente__
<p> Descrevi o tempo de extinção da espécie invasora em duas situações: considerando o tempo junto com a residente e o tempo parcial sem a residente, nas simulações em que houve substituição da residente. Na primeira situação é considerado a distribuição de tempos de extinção da invasora na presença da competidora, ou seja, os tempos totais até a espécie invasora se extinguir, seja ela a primeira ou última a se extinguir. Na segunda situação considerei apenas o tempo parcial de extinção na ausência da residente, ou seja, considerei que o tempo é zerado no momento do evento de substituição. Uma possível família de distribuição de probabilidades para descrever esses dados é a distribuição Gamma, pois mecanisticamente ela descreve o tempo de espera até que um certo número de eventos ocorra e em certas condições ela pode convergir para uma distribuição exponencial [@bolker2008]. A distribuição Gamma conta com dois parâmetros: de forma e de taxa. O parâmetro da taxa pode ser reescrito como a razão entre o parâmetro da forma e a média (primeiro momento) e a média pode ser definida como o exponencial do descritor linear em um GLM Gamma com função de ligação log [@bossio2015gamma]. Além disso, quando o parâmetro da forma é igual a 1 então a distribuição Gamma converge para uma distribuição exponencial [@bolker2008]. Para descrever o tempo de extinção na primeira situação, considerando a presença da residente, o mais adequado seria considerar um GLMM Gamma log (Apêndice), agrupando os valores das réplicas para uma mesma combinação única de parâmetros, porém isso dificultaria a estimativa do parâmetro da forma e da predição pelo modelo médio. Assim, escolhi usar o GLM Gamma log para obter a predição do modelo média para essa situação em tempo suficiente para elaborar o artigo completo. No GLM Gamma log usei as mesmas preditoras usadas no GLM Binomial logito.</p>

#### Trabalho Computacional

Todo o trabalho computacional foi feito no ambiente de programação R [@Rteam] usando os pacotes básicos e os pacotes adicionais trackdown [@trackdown], kableExtra [@kableExtra], bbmle [@bbmle], MuMIn [@MuMIn], AICcmodavg [@AICcmodavg] lme4 [@lme4], gridExtra [@gridExtra], doMC [@doMC], plyr [@plyr] e tidyverse [@tidyverse].

### Resultados

#### Como a probabilidade de substituição varia com o tamanho inicial da invasora e a assimetria competitiva?

<p>Uma expectativa era que quanto menor o tamanho populacional da espécie invasora menor a probabilidade de substituição, pois a chance de flutuações estocásticas extinguirem a espécie é maior quando a abundância está próxima de zero, mesmo em situações favoráveis. Outra expectativa é baseada nos cenários determinísticos da aproximação de campo médio. Exceto pelo cenário de equivalência das espécies (assimetria competitiva zero) que depende das condições iniciais e do regime de perturbações, dado tempo suficiente, a invasão resultará na substituição ou não da espécie residente, independente do tamanho inicial da espécie invasora. Os parâmetros de competição interespecífica variaram de tal forma que a exclusão da residente ocorreria quando a assimetria competitiva fosse positiva e a exclusão da invasora quando a assimetria competitiva fosse negativa (Figura 1b). Portanto, a expectativa era que a probabilidade de substituição iria aumentar com o tamanho populacional inicial da invasora e da assimetria competitiva.</p>
<p>A expectativa foi observada, na figura 2 há a probabilidade de substituição predita pelo modelo médio em função do tamanho inicial da invasora (eixo x = M0) e da assimetria competitiva (eixo y = C_nm), no painél principal a probabilidade média, nos dois de baixo o intervalo de confiança assintoticamente normal na escala da função de ligação logito [@AICcmodavg]. O predito pelo modelo médio mostra que o efeito da assimetria competitiva só se torna relevante quanto maior o tamanho populacional inicial da invasora: apenas a partir de M0 = 20 nota-se aumento da probabilidade de substituição com o aumento de C_nm (Figura 1). o GLM Binomial logito cheio selecionado considerou os efeitos do polinômio de segundo grau da assimetria competitiva e do log do tamanho inicial da espécie invasora sem o efeito da interação dos polinômios. Esse modelo cheio apresentou bom ajuste; e de fato, apesar das proporções observadas apresentarem grande variação (Figura A1), o predito se assemelha ao observado (Figura A2 e A3). A grande variação nas proporções observadas sugere que a capacidade de suporte é pequena, resultando em populações com flutuações elevadas.</p> 
  
```{r figura 2 Probabilidade de substituicao da residente pela invasora}
# dados
# graficos
## isolinhas
df_sim0 <- read_csv("csv/df_sim0.csv")
df_plot <- df_sim0 |> filter(C_nm %in% c(-0.5,0,0.5) & M0==2) |>  select(-M0)
beta = df_sim0$beta[1]
delta = df_sim0$delta[1]
gamma = df_sim0$gamma[1]
# equação 4a
f_IsoResidente <- function(x,C_n) (beta - delta) / C_n - x * gamma/(2*C_n)
f_IsoInvasora <- function(x,C_m) 2*(beta - delta)/gamma - 2*C_m*x/gamma
# curve(f_IsoResidente(x,C_n=df_plot$C_n[1]),from = 0,to = 50)
df_plot <- left_join(x=data.frame(x=rep(0:50,3),id = rep(c(1,6,11),each=51)),
                     y=df_plot,
                     by="id") |> 
  select(-id,-k) |> 
  mutate(n = f_IsoResidente(x=x,C_n=C_n),
         m = f_IsoInvasora(x=x,C_m=C_m))
l_p[[2]] <- df_plot |> 
  pivot_longer(cols = c("n", "m"),
               names_to = "species",
               values_to = "N") |> 
  mutate(C_nm = factor(C_nm,levels = c(0.5,0,-0.5)),
         species = factor(species,levels = c("n","m"))) |>
  ggplot(aes(x=x,y=N,color=species)) +
  geom_line(alpha=0.5,size=1.2) + 
  ylim(0,50) + 
  xlim(0,50) +
  scale_color_manual(labels = c("n", "m"),
                     values = c("blue", "red")) +
  coord_cartesian(expand = FALSE) +
  labs(x="n",y="m",color="",title="b) Isolinhas Campo Médio") +
  theme_bw() + theme(legend.position="right") +
  facet_wrap(~C_nm,ncol=1)
# probabilidade de substituição 
max_fill <- max(c(df_plot$mod.avg.pred,df_resultados$c_invasion/100,
                  df_plot$lower.CL,df_plot$upper.CL)) + min(df_resultados$c_invasion/100)
l_p <- list()
v_breaks <- c(as.numeric(round(quantile(df_plot$mod.avg.pred,probs = seq(0.10,0.50,length=5)),digits = 2)),max_fill/2)
l_p[[1]] <- ggplot(mutate(df_plot,label="Average"),
                   aes(x=M0,y=C_nm,fill=mod.avg.pred)) +
  geom_tile() +
  # geom_contour(aes(z=mod.avg.pred),alpha=0.2, colour="black",
  #              breaks = v_breaks) +
  # metR::geom_text_contour(aes(z=mod.avg.pred),stroke=0.05,
  #                         breaks = v_breaks) +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Prob. replacement",
       fill="Probability") +
  coord_cartesian(expand = FALSE) +
  facet_wrap(~label) +
  theme_classic()
l_p[[2]] <- ggplot(df_plot,aes(x=M0,y=C_nm,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p[[3]] <- ggplot(df_plot,aes(x=M0,y=C_nm,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(grobs=l_p,
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )

```
  
  
__Figura 2__ Probabilidade de substituição da espécie residente pela invasora. Eixo x = tamanho inicial da espécie invasora, M0. Eixo y = assimetria competitiva, definida como $(C_n - C_m)2/\gamma$, $C_n$ e $C_m$ variaram entre $\gamma/2$ e $\gamma/4$. No painel principal há a probabilidade média predita pelo modelo médio e nos painéis de baixo o intervalo de confiança de 5% e 95% assintoticamente normal na escala da função de ligação logito.

#### Como a presença da residente reduz o tempo de extinção da invasora?

<p>Uma expectativa era que na presença da competidora, qualquer espécie sofreria alguma redução no tamanho populacional. Em um sistema estocástico, quanto menor o tamanho populacional maior as chances de extinção devido a estocasticidade demográfica, assim a presença da competidora implicaria em redução do tempo médio de extinção. Outra expectativa é que quanto maior a assimetria competitiva menor deve ser a influência da residente na invasora, enquanto a influência per capita da invasora deve ser similar à influência da residente nela mesma. Portanto, a expectativa era de que a redução no tempo de extinção deveria ser menor quanto maior a assimetria competitiva.</p>
<p>A expectativa foi observada principalmente quando o tamanho inicial da invasora foi próximo da capacidade de suporte (Figura 3a). Na figura 3a há os pontos observados de tempo de extinção da espécie invasora considerando os tempos totais; em vermelho o predito para os tempos totais, essa predição varia entre os painéis em função da assimetria competitiva; em azul o predito pelo modelo médio para o conjunto de tempos parciais, em que o tempo da invasora com a residente foi desconsiderado, essa predição é igual nos três painéis. Para obter a predição para o conjunto de tempos parciais desconsiderei as simulações onde o tamanho da invasora no momento da substituição foi maior do que 50 ou menor do que 2. Os tempos de extinção nas duas situações são marcados pela variabilidade no conjunto de dados (FIgura A4, A6 e A9) e o GLM Gamma log não apresentou um excelente ajuste (Figura A5 e A11). O parâmetro da forma estimado pelo GLM Gamma log para os tempos de extinção parciais foi 0.933 (Erro Padrão da estimativa = 0.023, tabela A6) e para os tempos de extinção totais foi 0.929 (Erro Padrão da estimativa = 0.010, tabela A9), indicando que os GLM Gamma log ajustados pressupõem que a distribuição de valores se assemelhava a uma distribuição exponencial. Esse pressuposto pode ser uma boa aproximação para tamanhos iniciais pequenos, mas piora quanto maior o tamanho inicial da invasora, onde a moda se desloca do zero, principalmente quanto maior a assimetria competitiva ou na situação de ausência da residente (Figura 3b).</p>




```{r figura 3, fig.height=9.85,fig.width=8.5}
# preparação dos dados
## df_plot_2spp
df_plot_2spp <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5))
df_plot_2spp <- left_join(df_plot_2spp,
                      ddply(df_plot_2spp,"M0",summarise,avg_logTE = mean(log_TE),sd_logTE = sd(log_TE)),
                      by="M0")
### df_plot_1spp
df_plot_1spp <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> 
  arrange(M0) |> 
  filter(M0 %in% unique(df_plot_2spp$M0))
df_plot_1spp <- left_join(df_plot_1spp,
                          ddply(df_plot_1spp,"M0",summarise,avg_logTE = mean(log_TE),sd_logTE = sd(log_TE)),
                          by="M0") |> 
  select(M0,mod.avg.pred:sd_logTE) |> 
  distinct()
names(df_plot_1spp)[-1] <- paste0(names(df_plot_1spp)[-1],"_1sp") 
### df_plot
df_plot <- left_join(df_plot_2spp,df_plot_1spp,by="M0")
# gráficos
l_p <- list()
# observado e predito nas duas stiauções
l_p[[1]] <- df_plot |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  geom_ribbon(aes(ymin=lower.CL_exp_1sp,ymax=upper.CL_exp_1sp),alpha=0.5,color="blue",fill="blue",alpha=0.5) +
  geom_line(aes(y=mod.avg.pred_exp_1sp),color="blue",alpha=0.5) +
  labs(y="Tempo Extinção (anos)",x="Tamanho inicial invasora", title = "a) Tempo para Extinção da inv. na presença da residente e as predições") +
  facet_wrap(~C_nm,ncol=3)
# figura 3 b
# preparação dos dados
## df_plot_2spp
df_plot_2spp <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5), M0 %in% c(2,25,50)) |> 
  select(TE:M0,C_nm) |> mutate(C_nm = as.character(C_nm))
### df_plot_1spp
df_plot_1spp <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> 
  arrange(M0) |> 
  filter(M0 %in% unique(df_plot_2spp$M0)) |> 
  select(TE:M0) |> mutate(C_nm = "1sp")
### df_plot
df_plot <- rbind(df_plot_2spp,df_plot_1spp) |> 
  mutate(across(M0:C_nm,factor))
### l_p[[2]]
l_p[[2]] <- df_plot |> 
  ggplot(aes(x=TE)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  labs(x="Tempo de Extinção",title = "b) Distr. de Tempos para Extinção da invasora") +
  facet_grid(M0~C_nm,scales="free")
# grid arrange
grid.arrange(grobs=l_p,
             layout_matrix=rbind(1,1,1,2,2,2,2))
```

__Figura 3__ Tempo de Extinção da espécie invasora. a) Tempos de Extinção observado na presença da residente (pontos) e predito (vermelho) e o predito para o tempo de extinção na ausência da residente (azul). Eixo x = tamanho inicial da espécie invasora (indivíduos), M0. Eixo y = Tempo de Extinção da invasora (anos), TE. No título dos painéis a assimetria competitiva. b) Gráficos descritivos da distribuição de tempos de extinção nos cenários simulados de assimetria competitiva ou de ausência de residente (título superior dos painéis) e para o tamanho inicial da espécie invasora (título lateral dos painéis). 

### Discussão

- Quanto maior o tamanho populacional da invasora maior a probabilidade de observar o esperado pela aproximação de campo médio (Figura 1).
- Mesmo em tamanhos populacionais elevados, a estocasticidade demográfica previne cerca de 40% dos casos esperados nos cenários de assimetria competitiva mais extremos (Figura 1).
- Esse resultado sugere que o sistema é muito influenciado pela estocasticidade demográfica.
- Nos cenários de assimetria mais extremos, o tamanho populacional inicial da invasora necessário para substituir a residente em sua capacidade de suporte, o critério de invasibilidade, é o dobro da capacidade de suporte para a competidora inferior.
- Assim, uma expectativa é que as flutuações nos tamanhos populacionais possam ser bem mais elevados do que a capacidade de suporte


```{r grafico exploratorio }
df_plot <- read_csv("resultados/df_rep_tFinal.csv") |> 
  filter(invasion == 0 & M0 %in% c(2,25,50) & C_nm %in% c(-0.5,0,0.5)) |> 
  select(id,k,M0,C_nm,n,t) |> 
  mutate(across(M0:C_nm,factor),
         t=t/365.25)
df_plot |> 
  ggplot(aes(y=n,x=M0)) +
  geom_boxplot() +
  geom_jitter(aes(color=t),alpha=0.6) +
  facet_wrap(~C_nm) +
  labs(title="Como a população residente que sobrevive é influenciada pela invasão?",
       subtitle = "Tamanho Populacional da Residente quando a substituição não ocorreu:",
       color="t (anos)")

```





### Agradecimentos

### Apêndice

<!-- ## Códigos para rodar as simulações estocasticas e deterministicas -->

```{r time estimative, include=FALSE,echo=FALSE,eval=FALSE}
f_2sppSLV(N0=50, beta_n = 0.7/365.25, delta_n = 0.69/365.25, gamma_n = (0.7/365.25 - 0.69/365.25)/50, C_n =  (0.7/365.25 - 0.69/365.25)/50,
          M0=50, beta_m = 0.7/365.25, delta_m = 0.69/365.25, gamma_m = (0.7/365.25 - 0.69/365.25)/50, C_m =  (0.7/365.25 - 0.69/365.25)/50,replicas = 50)
start_time <- Sys.time()
plyr::rdply(.n = 2,f_loop())
end_time <- Sys.time()
end_time - start_time
```

```{r simulação do modelo estocastico, eval=FALSE,echo=FALSE,include=TRUE}
registerDoMC(3)
plyr::a_ply(df_sim,1,
            function(X) do.call("f_2sppSLV",
                                list(N0=X$k,beta_n=X$beta,delta_n=X$delta,gamma_n=X$gamma,C_n=X$C_n,
                                     M0=X$M0,beta_m=X$beta,delta_m=X$delta,gamma_m=X$gamma,C_m=X$C_m,
                                     replicas=50,path_csv=X$path)),
            .parallel = TRUE)
```

<!-- ### the mean field approximation -->

```{r modelo deterministico,eval=FALSE,include=FALSE,echo=FALSE}
f_2sppDLV <- function(X,max_t,int_t,path_csv){
 f_ode<- function(t,y,p){
   N <- y[1]
   M <- y[2]
   with(as.list(p),{
     dNdt <- (beta - delta)*N - gamma*(N^2)/2 - C_n*N*M
     dMdt <- (beta - delta)*M - gamma*(M^2)/2 - C_m*M*N
     return(list(c(dNdt,dMdt)))
   })
   }
 p <- unlist(select(X,beta:gamma,C_n:C_m))
 y0 <- unlist(X[,c("k","M0")])
 names(y0) <- c("N","M")
 times <- seq(0,max_t,int_t)
 df_ab.det <- ode(y=y0,times = times,func = f_ode,parms = p)
 df_ab.det <- as.data.frame(df_ab.det)
 readr::write_csv(x = df_ab.det,file=path_csv)
}
```

```{r simulacao do modelo deterministico,echo=FALSE,eval=FALSE}
# resultados dos modelos estocasticos
df_resultados <- read_csv(file = "resultados/df_resultados.csv") |> 
  mutate(t_max_anos = t_max/365.25)
# df_resultados$t_max_anos |> summary()
# df par simulações
df_sim2 <- inner_join(df_sim0,
                      select(df_resultados,id,t_max_anos),
                      by="id") |> 
  mutate(path=paste0("csv/md_CampoMedio/id_",id,".csv"))
# simulação
# X <- df_sim2[1,]
intervalo_EulerMethod <- 0.02
registerDoMC(3)
plyr::a_ply(df_sim2,1,
            function(df) f_2sppDLV(X=df, 
                                   max_t = (df$t_max_anos+10*intervalo_EulerMethod),
                                   int_t = intervalo_EulerMethod,path_csv = df$path),
            .parallel = TRUE)
```
  
    
<!-- ## Cálculo das métricas de avaliação   -->

<!-- ### Contagem de eventos de substituição  -->
    
      
```{r análises preparatórias 1 - df_resultados e df_replicas, eval=FALSE, echo=FALSE, include=FALSE}
df_sim <- read_csv("csv/df_sim0.csv")
f_resultados <- function(X){
  df <- read_csv(X$path)
  read_csv(X$path) |>
    group_by(.n) |>
    slice_tail(n=1) |>
    mutate(invasion=ifelse(m==0 & n==0,1,0))
}
registerDoMC(3)
df_rep.tFinal <- adply(df_sim,1,f_resultados,.parallel = TRUE)
write_csv(df_rep.tFinal,file="resultados/df_rep_tFinal.csv")
######
df_tFinal <- df_rep.tFinal |> 
  group_by(id) |>
  summarise(c_invasion = sum(invasion),
            t_mean = mean(t),
            t_var = var(t),
            t_max = max(t),
            n_mean = mean(n),
            n_var = var(n)) |> 
  inner_join(distinct(select(df_rep.tFinal,id:M0)),by="id") |> 
  mutate(C_nm = (C_n - C_m)*2/df_sim$gamma[1]) |> 
  arrange(C_nm)
write_csv(df_tFinal,file = "resultados/df_tFinal.csv")
# df_resResidente
# df <- df_rep.tFinal |> filter(id==1)
f_TEres <- function(df){
  df_ab <- read_csv(df$path[1]) |> 
    filter(.n %in% unique(df$.n[df$invasion==1]))
  df_ab[df_ab$n==0,] |> group_by(.n) |> slice_head()
}
registerDoMC(3)
df_res0 <- ddply(df_rep.tFinal,"id",f_TEres,.parallel = TRUE)
df_tParcial <- left_join(rename(df_res0,TE_res=t),
                         select(filter(df_rep.tFinal,invasion==1),id,.n,M0,C_nm,t),
                         by=c("id",".n")) |> 
  mutate(TE_1sp = t - TE_res)
write_csv(df_tParcial,file = "resultados/df_tParcial.csv")
```

  
#### Modelos estatísticos

##### Proporção de eventos de substituição em 100 réplicas

```{r graf exp prob replace the resident, echo=FALSE,include=TRUE,eval=TRUE}
df_resultados <- readr::read_csv("resultados/df_tFinal.csv")
df_resultados <- df_resultados |> 
  mutate(Prob_invasion = c_invasion/100,
         propM0 = M0/50,
         t_sd=sqrt(t_var))
df_resultados |> 
  ggplot(aes(x=propM0,y=C_nm,fill=Prob_invasion)) +
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  labs(fill="",x="M0, initial pop. size of invader (%K)",y="(Cn - Cm) 2 / gamma") +
  coord_cartesian(expand = FALSE) +
  geom_text(aes(label=Prob_invasion)) +
  ggtitle("Proporção de eventos de substituição da residente em 100 réplicas") +
  theme_classic()
```

__Figura A1__ Proporção observada de substituições 
  
    
__tabela A1__ seleção de GLM Binomial Cheio para descrever a probabilidade de substituição

```{r modelo estatístico para descrever a probabilidade de invasao,echo=FALSE,include=FALSE,eval=TRUE}
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# glm binomial
l_md <- list()
l_md[[1]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[2]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[3]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[4]] <- glm(cbind(c_invasion,100-c_invasion) ~ (M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[5]] <- glm(cbind(c_invasion,100-c_invasion) ~ 1,
                 family = "binomial",data=df_resultados)
l_md[[6]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[7]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[8]] <- glm(cbind(c_invasion,100-c_invasion) ~ (log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
names(l_md) <- c("C_nm^2 * M0^2","C_nm^2 + M0^2","C_nm^2","M0^2","1","C_nm^2 * log_M0^2","C_nm^2 + log_M0^2","log_M0^2")
AICctab(l_md,weights=TRUE)
```

 
```{r graficos diagnostico do GLM binomial mais plausível,include=TRUE,eval=TRUE}
res.Dharma <- DHARMa::simulateResiduals(l_md[["C_nm^2 + log_M0^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```
    
__Figura A2__ Resíduos Quantílicos GLM Binomial cheio. Resíduos quantílícos obtidos com a função simulateResiduals do pacote DHARMa, com 250 simulações.  
  

__tabela A2__ Sumário do modelo 1: GLM Binomial Cheio  

```{r sumário do GLM binomial cheio}
summary(l_md[["C_nm^2 + log_M0^2"]])
```

    
##### Modelo Médio
  
    
```{r construcao do modelo medio GLM Binomial,eval=FALSE,echo=FALSE}
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# modelo referência
md_ref <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)) + (log_M0.z + I(log_M0.z^2)),
              family = "binomial",data=df_resultados,na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for new data predictions
df_pred <- expand.grid(M0=seq(min(df_resultados$M0),max(df_resultados$M0),length=60),
                       C_nm.z=seq(min(df_resultados$C_nm.z),max(df_resultados$C_nm.z),length=60)) |> 
  mutate(log_M0 = log(M0))
df_pred$log_M0.z <- f_z(df_pred$log_M0)
# esse demora com esse tanto de pontos
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_pred,type="link") %>%
  cbind(df_pred)
df_GLMBin_modavg <- df_AICcmodavg |> 
  select(mod.avg.pred,lower.CL,upper.CL,C_nm.z) |> 
  mutate(C_nm = C_nm.z*sd(df_resultados$C_nm) + mean(df_resultados$C_nm),
         across(mod.avg.pred:upper.CL,arm::invlogit))
df_GLMBin_modavg$M0 <- df_AICcmodavg$M0
write_csv(df_GLMBin_modavg, file="resultados/df_GLMBin_modavg.csv")
```
  
    
```{r glm binomial observado e predito modelo medio, echo=F, comment=FALSE, message=FALSE,warning=FALSE,results="hide"}
# dados
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# modelo referência
md_ref <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)) + (log_M0.z + I(log_M0.z^2)),
              family = "binomial",data=df_resultados,na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for the observed data
mdAvg_MuMIn <- model.avg(l_dredge_nInvasions)
# Predição
df_md <- df_resultados
# interval = 'confidence' ainda não é usado, apenas para uma avaliação visual
df_md$Pr_invasion <- predict(mdAvg_MuMIn,type="response")*100
# Gráfico
colors <- c("loess" = "blue", "1 : 1" = "black")
ggplot(df_md,aes(x=c_invasion,y=Pr_invasion)) +
  geom_smooth(aes(color="loess"),method = "loess",formula = "y~0+x") +
  geom_abline(aes(color="1 : 1"),slope=1,intercept = 0) +
  geom_point() + 
  labs(x="número de substituições",
       y="predito pelo modelo médio",
       title="GLM Binomial Logito: Predito pelo modelo médio X Observado",
       color = "") +
  scale_color_manual(values = colors)
```
    
__Figura A3__ GLM Binomial Logito: predito pelo modelo médio e observado.   

#### Tempo de Extinção

##### Tempo para extinção na ausência de competidora

```{r analise dos dados de tempo de extincao conjunto completo, fig.height=5,fig.width=8}
df_1sp <- read_csv(file="resultados/df_tParcial.csv") |> 
  dplyr::select(-M0,-(id:n),-(TE_res:t)) |> 
  dplyr::rename(M0 = m) |> 
  dplyr::mutate(TE = TE_1sp/365.25,
         log_TE = log(TE),
         log_M0 = log(M0))
l_p <- list()
l_p[[1]] <- df_1sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_1sp |> 
  pivot_longer(cols=c("M0","log_M0"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x="",y=valores)) +
  geom_jitter(alpha=0.2) +
  geom_boxplot() +
  facet_wrap(~variaveis,scales="free")
l_p[[3]] <- df_1sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_1sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Conjunto Completo")
```
```{r analise dos dados de tempo de extincao conjunto M0 menor ou igual 50, fig.height=5,fig.width=8}
df_1sp <- df_1sp |> filter(M0<=50 & M0>1)
l_p <- list()
l_p[[1]] <- df_1sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_1sp |> 
  pivot_longer(cols=c("M0","log_M0"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x="",y=valores)) +
  geom_jitter(alpha=0.2) +
  geom_boxplot() +
  facet_wrap(~variaveis,scales="free")
l_p[[3]] <- df_1sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_1sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Conjunto Parcial: 50 >= tamanho inicial > 1")
```

__Figura A4__ Conjunto de dados completo do Tempo estimado de extinção na ausência da competidora e conjunto de dados parcial considerando M0 <50 e 

###### Ajuste modelo cheio GLM Gamma log Tempo de Extinção sistema com 1 sp

__Tabela A6__ Tabela seleção do modelo referência para descrever o Tempo de Extinção no sistema com 1 sp.  

```{r ajuste modelo cheio lm TE 1sp 1 }
# modelos
l_md <- list()
l_md[[1]] <- glm(TE ~ M0 + I(M0^2),data = df_1sp,Gamma(log))
l_md[[2]] <- glm(TE ~ M0,data = df_1sp,Gamma(log))
l_md[[3]] <- glm(TE ~ log_M0 + I(log_M0^2),data = df_1sp,Gamma(log))
l_md[[4]] <- glm(TE ~ log_M0,data = df_1sp,Gamma(log))
l_md[[5]] <- glm(TE ~ 1,data = df_1sp,Gamma(log))
names(l_md) <- c("M0^2","M0","log(M0)^2","log(M0)","1")
AICctab(l_md,weights=TRUE)
```

```{r graficos diagnostico do LM referencia TE 1sp 1 ,include=TRUE,eval=TRUE}
res.Dharma <- DHARMa::simulateResiduals(l_md[["log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```
    
__Figura A5__ GLM Gamma log (Tempo Extinção 1sp): Resíduos Quantílicos do modelo cheio para descrever o tempo de extinção na ausência de residente. Resíduos quantílícos obtidos com a função simulateResiduals do pacote DHARMa, com 250 simulações.  
  

__tabela A6__ Sumário do modelo 2: GLM Gamma log (Tempo Extinção 1sp) cheio selecionado, TE ~ poli(log(M0),2)

```{r sumário do LM referencia do tempo de extincao na ausencia da residente 1 }
summary(l_md[["log(M0)^2"]])
print("MASS::gamma.shape return:")
MASS::gamma.shape(l_md[["log(M0)^2"]])
```

####### Modelo Médio GLM Gamma log Tempo de Extinção sistema com 1 sp

```{r TE single specie, eval=FALSE}
# modelo referência
md_ref <- glm(TE ~ log_M0 + I(log_M0^2),data = df_1sp, na.action = "na.fail",Gamma(log))
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# model averaging prediction
v_gamma.shape = MASS::gamma.dispersion(md_ref)
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_1sp,type="link",gamdisp=v_gamma.shape) %>%
  cbind(df_1sp) |> 
  select(TE,log_TE,M0,log_M0,mod.avg.pred,lower.CL,upper.CL) |>
  mutate(across(mod.avg.pred:upper.CL,exp,.names="{.col}_exp"))
write_csv(df_AICcmodavg,file = "resultados/df_GLMGamma_modavg_1sp.csv")
```
```{r graficos glm gamma log TE 1sp,echo=FALSE,fig.width=10,fig.height=5}
df_AICcmodavg <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> arrange(M0)
l_p <- list()
l_p[[1]] <- df_AICcmodavg |> 
  mutate(label = "y: escala função de ligação; x: escala preditora do GLM") |> 
  ggplot(aes(x=log_M0,y=log_TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL,ymax=upper.CL),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred)) +
  labs(y="log(TE)",x="log(M0)") +
  facet_wrap(~label)
l_p[[2]] <- df_AICcmodavg |> 
  mutate(label = "y e x: escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  labs(y="TE (anos)",x="M0 (indivíduos)") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="GLM Gamma(log) TE 1sp: Observado e Predito pelo ")
```
 
  
__Figura A6__ Observado e predito GLM Gamma(log) modelo médio
  
  
##### Tempo de extinção na presença da residente
  
```{r graficos exploratorios TEI 2spp,echo=FALSE}
df_2sp <- read_csv(file="resultados/df_rep_tFinal.csv") |> 
  dplyr::select(id,M0,C_nm,t,invasion) |> 
  dplyr::mutate(TE = t/365.25,
         dplyr::across(c(TE,M0),log,.names="log_{.col}"))
l_p <- list()
l_p[[1]] <- df_2sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_2sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=C_nm,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[3]] <- df_2sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_2sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Tempo de Extinção total: sucesso e fracasso na substituição da espécie residente")
```
  
__Figura A9__ Gráficos exploratórios do Tempo de Extinção total: quando a substituição foi um sucesso ou fracasso    

__Tabela A7__ Seleção do modelo cheio para descrever o tempo de extinção total.  
  
  
```{r ajuste modelo cheio TEI 2spp 1 }
# dados
df_2sp <- read_csv(file="resultados/df_rep_tFinal.csv") |> 
  mutate(log_M0 = log(M0),
         TE = t/365.25) |> 
  select(id,TE,M0,log_M0,C_nm)
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_2sp$M0.z <- f_z(df_2sp$M0)
df_2sp$log_M0.z <- f_z(df_2sp$log_M0)
df_2sp$C_nm.z <- f_z(df_2sp$C_nm)
# modelos
l_md <- list()
l_md[[1]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[2]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[3]] <- glmer(TE ~ (M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[4]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[5]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[6]] <- glmer(TE ~ (log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[7]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[8]] <- glmer(TE ~ 1 + (1|id),data = df_2sp, Gamma(log))
l_md[[9]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[10]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[11]] <- glm(TE ~ (M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[12]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[13]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[14]] <- glm(TE ~ (log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[15]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2)),data = df_2sp, Gamma(log))
l_md[[16]] <- glm(TE ~ 1,data = df_2sp, Gamma(log))
names(l_md) <- c("GLMER:: C_nm^2 * M0^2","GLMER:: C_nm^2 + M0^2","GLMER:: M0^2",
                 "GLMER:: C_nm^2 * log(M0)^2","GLMER:: C_nm^2 + log(M0)^2","GLMER:: log(M0)^2",
                 "GLMER:: C_nm^2","GLMER:: 1",
                 "GLM:: C_nm^2 * M0^2","GLM::C_nm^2 + M0^2","GLM:: M0^2",
                 "GLM:: C_nm^2 * log(M0)^2","GLM:: C_nm^2 + log(M0)^2","GLM:: log(M0)^2",
                 "GLM:: C_nm^2","GLM:: 1")
AICctab(l_md,weights=TRUE)
```

__Tabela A8__ sumário do glmer Gamma(log) TE 2spp cheio mais plausível: C_nm^2 + log(M0)^2  
  
```{r tabela A8}
summary(l_md[["GLMER:: C_nm^2 + log(M0)^2"]])
```

```{r residuos quantilicos lmer TEI 2spp}
res.Dharma <- DHARMa::simulateResiduals(l_md[["GLMER:: C_nm^2 + log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```

__Figura A10__ "GLMER:: C_nm^2 * M0^2" Resíduos quantílicos glmer Gamma(log) TE 2spp cheio, C_nm^2 + log(M0)^2



__Tabela A9__ sumário do GLM Gamma(log) TE 2spp cheio mais plausível: C_nm^2 + log(M0)^2  

```{r}
summary(l_md[["GLM:: C_nm^2 + log(M0)^2"]])
print("MASS::gamma.shape return:")
MASS::gamma.shape(l_md[["GLM:: C_nm^2 + log(M0)^2"]])
```

```{r Figura A11 glm GAMMA cheio}
res.Dharma <- DHARMa::simulateResiduals(l_md[["GLM:: C_nm^2 + log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```

__Figura A11__ GLM Gamma log TE 2spp: Resíduos quantílicos, C_nm^2 + log(M0)^2

####### GLM Gamma log TE 2spp: Modelo Médio

```{r modelo medio glm gamma 2sp,eval=FALSE}
# modelo referência
md_ref <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log), na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# model averaging prediction
v_gamma.shape = MASS::gamma.dispersion(md_ref)
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_2sp,type="link",gamdisp=v_gamma.shape) %>%
  cbind(df_2sp) 
df_GLMGamma_modavg_2spp <- df_AICcmodavg |> 
  mutate(log_TE = log(TE)) |> 
  select(TE,log_TE,M0,log_M0,C_nm,mod.avg.pred,lower.CL,upper.CL) |>
  mutate(across(mod.avg.pred:upper.CL,exp,.names="{.col}_exp"))
write_csv(df_GLMGamma_modavg_2spp,file = "resultados/df_GLMGamma_modavg_2spp.csv")
```
```{r predito e observado df GLMGamma modavg 2spp´}
df_AICcmodavg <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5))
l_p <- list()
l_p[[1]] <- df_AICcmodavg |> 
  ggplot(aes(x=log_M0,y=log_TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL,ymax=upper.CL),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred)) +
  labs(y="log(TE)",x="log(M0)") +
  facet_wrap(~C_nm,ncol=3)
l_p[[2]] <- df_AICcmodavg |> 
  mutate(label = "y e x: escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  labs(y="TE (anos)",x="M0 (indivíduos)") +
  facet_wrap(~C_nm,ncol=3)
grid.arrange(grobs=l_p,ncol=1,top="GLM Gamma(log) TE 2spp: Observado e Predito")
```

### Referências
