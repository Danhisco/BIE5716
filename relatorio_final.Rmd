---
title: "Generalization of the stochastic logistic model to interspecific competition"
author: "Danilo Pereira Mori"
date: "2022-08-20"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,message = FALSE,warning = FALSE,cache = TRUE)
```

```{r google docs management, eval=FALSE,include=FALSE}
library(trackdown)
# both overwrite: 
# to update:
upload_file(file ="relatorio_final.Rmd",
            gpath = "mestrado/disciplinas/BIE5716/",
            hide_code = TRUE)

```

# Introdução
O modelo de crescimento exponencial incorpora o princípio fundamental de que a vida provém de outra e assim examina o comportamento de uma população que pode crescer sem limitação alguma. Ao incluir a influência que o aumento na densidade populacional pode ter na limitação do crescimento, o modelo logístico incorpora outro princípio fundamental que é o da perda de excedente de indivíduos esperado por um crescimento ilimitado. Caso uma população crescesse de forma exponencial todo o universo conhecido poderia estar colonizado por um único tipo de vida. Outro componente essencial da modulação dos eventos demográficos é a interação com outras espécies. Aqui vamos explorar um modelo de competição de 2 populações em crescimento denso dependente, N e M.

Vamos modelar o sistema usando um arcabouço de processos de difusão (Gillespie 1977) onde as reações individuais, microscópicas, são explicitadas com a intenção de descrever o comportamento macroscópico do sistema em termos do tamanho populacional das espécies.
Aqui perguntamos como a estocasticidade demográfica pode modificar o esperado pela aproximação de campo médio nos cenários de invasão. Avaliamos o aumento do tamanho populacional da invasora e a variação na assimetria competitiva entre as duas espécies. Descrevo as reações demográficas consideradas, a equação mestra da dinâmica ecológica e as aproximações de campo médio da equação mestra. Então comparo com o observado numericamente usando uma implementação do algortimo de Gillespie (1977).

## Reações  
  
Vamos modelar a mudança de estado do sistema, descrito por (n,m), onde n e m são a abundância de N e M, respectivamente. O modelo considera possíveis mudanças discretas de 1 indivíduo no sistema em um intervalo de tempo muito pequeno dt. As oito reações consideradas estão disponíveis na tabela 1, elas constituem um modelo de denso depedência em que a competição interespecífica é modelada de forma similar à da competição intraespecífica: pela probabilidade de exclusão de um dos dois indivíduos por evento de colisão. O modelo pressupõe que não é possível distinguir entre indivíduos de uma mesma espécie, assim, o parâmetro $\gamma$ descreve a probabilidade de qualquer um dos dois indivíduos ser excluído, por isso ele está dividido por 2.


```{r tabela 1}
library(knitr)
library(kableExtra)
df_tabela1 <- data.frame(reactions = c("n -> n + n","n -> 0","n + n -> n","n + m -> m",
                                       "m -> m + m","m -> 0","m + m -> m","m + n -> n"),
                         description = c("reprod. assex. de N","morte de N","comp. intraesp. de N","exclusão de N por M",
                                         "reprod. assex. de M","morte de M","comp. intraesp. de M","exclusão de M por N"),
                         Prob_dt = c("$\\beta n$","$\\delta n$","$\\gamma n (n-1) 2^{-1}$","$\\text{C}_{n} n m$",
                                     "$\\beta m$","$\\delta m$","$\\gamma m (m-1) 2^{-1}$","$\\text{C}_{m} m n$"),
                         unit_ParDemog = c("$P(nasc. de N)/ind. de N  dt$", "$P(morte de N)/ind. de N dt$",
                                           "$P(exclusão de N)/colisão N dt$","$P(exclusão de N)/colisão N M dt$",
                                           "$P(nasc. de M)/ind. de M dt$", "$P(morte de M)/ind. de M dt$",
                                           "$P(exclusão de M)/colisão M dt$","$P(exclusão de M)/colisão M N dt$"))
df_tabela1 %>%
  kbl(caption = "Tabela 1. Possíveis reações no modelo estocástico de competição de duas espécies sob denso dependência",
      col.names = c("reações","descrição","P(reação)/dt","unidade do parâmetro")) %>%
  kable_classic(full_width = T, html_font = "Cambria")

```
  
## The master equation and the mean-field approximation   
   
     
A partir das reações é possível desenvolver uma equação mestra que descreve a taxa de mudança da probabilidade de um determinado estado [$\frac{\partial P(n,m,t)}{\partial t}$] pela diferença na taxa da probabilidade de entrada e saída deste estado (equação 1). Na primeira linha depois da igualdade, há a soma das taxa com que N pode perder um indivíduo, indo do estado (n+1,m) para o estado (n,m). Na segunda linha a taxa com que N pode ganhar um indivíduo, indo do estado (n-1,m) para o estado (n,m). Nas linhas 3 e 4 a mesma lógica para M. Na quinta linha há a taxa com que o sistema pode permanecer no estado (n,m). Para detalhes veja tabela 1.


$$
\frac{\partial P(n,m,t)}{\partial t} = \\
P(n+1,m) (n+1) (\delta_n + n \gamma_n / 2 + m C_{n}) +\\ P(n-1,m) (n-1) \beta_n+\\ 
P(n,m+1) (m+1) (\delta_m + m \gamma_m / 2 + n C_{m}) +\\ P(n,m-1) (m-1) \beta_m+\\
- P(n,m)[n(\beta_n + \delta_n + (n-1) \gamma_n / 2 + m C_{n}) + m(\beta_m + \delta_m + (m-1) \gamma_m / 2 + n C_{m})]
$$


Com a equação mestra é possível descrever a taxa de mudança da probabilidade de todos os possíveis estados do sistema (n,m). Uma aproximação possível para estudar possíveis cenários é a de campo médio (mean field). Nessa aproximação buscamos obter o primeiro momento da distribuição de probabilidade marginal de N, E[N] = <n>, e de M, E[M] = <m>. Para isso é necessário estabelecer algumas definições: $<n> = \sum_{n=0}^{\infty} n P(n,m,t)$; $<n^2> = \sum_{n=0}^{\infty} n^2 P(n,m,t)$; $<m> = \sum_{m=0}^{\infty} m P(n,m,t)$; $<m^2> = \sum_{m=0}^{\infty} m^2 P(n,m,t)$; $<nm> = \sum_{n=0}^{\infty}\sum_{m=0}^{\infty} nm P(n,m,t)$. Para obter o primeiro momento basta multiplicar a equação mestra por n ou m e realizar o somatório (apêndice 1), e então é possível obter as equações 2a e 2b:

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n^2>\gamma_n2^{-1} - <nm>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m^2>\gamma_m2^{-1} - <mn>C_m
$$

A aproximação de campo médio pressupõe que $<n>^2 = <n^2>$, $<m>^2 = <m^2>$, $<nm> = <n><m>$. Esse pressuposto implica que a variância da dinâmica populacional denso dependente é zero e que as populações são independentes. Outro pressuposto possível para simplificar a aproximação é de que $\beta$ ou $\delta$ >> $\gamma$, assim $\gamma$ pode ser omitido como fator do primeiro momento. Essa aproximação é útil pois permite a convergência das equações acima com o modelo determinístico de competição interespecífica de duas populações com crescimento denso dependente (eq. 3a e 3b). A investigação desse modelo determinístico mostra o quê poderiamos esperar no equilíbrio caso não houvesse nenhuma flutuação devido à estocasticidade dos eventos demográficos.

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n>^2\gamma_n2^{-1} - <n><m>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m>^2\gamma_m2^{-1} - <m><n>C_m
$$
    
## Cenários de Assimetria Competitiva  
  
Para facilitar as análises vamos variar apenas o parâmetro que ajusta a probabilidade de exclusão de uma espécie pela outra por colisão (parâmetros $C_n$ e $C_m$, tabela 1). Os demais parâmetros populacionais serão iguais: $\beta =$ `r format(0.7/365.25,scientific = TRUE,digits = 4)`, $\delta =$ `r format(0.69/365.25,scientific = TRUE,digits = 4)`, $\gamma =$ `r format(2*(0.7/365.25-0.69/365.25)/50,scientific = TRUE,digits = 4)`. Os parâmetros de competição interespecífica ($C_n$ e $C_m$) vão variar entre $C_n = C_m = \gamma$ e $C_n = C_m = 2\gamma$, explorando dois extremos onde a espécie residente pode ser a espécie competitiva superior ou inferior. 


## The computacional model

É possível simular computacionalmente as possíveis trajetórias do sistema implementando o algoritmo de Gillespie (1977). A ideia do algoritmo se baseia no fato de que a distribuição de tempos entre mudanças de estados pode ser descrita por uma distribuição exponencial, então computamos separadamente as mudanças de estado e o tempo entre mudanças. O tempo entre mudança de estados pode ser obtido pela divisão do log de um valor de uma distribuição uniforme padrão pela soma das taxas de saída do estado (janela de código 1). Existem 4 possíveis transições de estado: cada uma das duas espécies pode ganhar ou perder um indivíduo por evento demográfico no intervalo de tempo dt. A taxa de ganho de um indivíduo de N ($n\_p$) é  $n\_p=\beta n$. A taxa de perda de um indivíduo de N ($n\_m$) é $n\_m = n[\delta +(n-1)\gamma2^{-1} + mC_n]$. A mesma lógica se aplica para as taxas de ganho e perda da espécie M (eq. 1 e janela de código 1). Após o sorteio do próximo tempo do evento de mudança de estado, é feito um sorteio da mudança de estado com probabilidade de cada estado dado pela contribuição relativa de cada taxa descrita anteriormente (janela de código 1), então o sistema é atualizado. Nossa simulação termina quando alguma população atinge o zero. Os cenários de competição explorados estão na figura 1.   


__janela de código 1__

```{r the computacional model,echo=TRUE,eval=TRUE}
f_2sppSLV <- function(N0,beta_n,delta_n,gamma_n,C_n,
                      M0,beta_m,delta_m,gamma_m,C_m,
                      replicas,path_csv){
 df_ab <- data.frame(n=N0,m=M0,t=0)
 df_t <- data.frame(n=c(1,-1,0,0), # 4 possibles transitions:
                    m=c(0,0,1,-1)) # n + 1, n - 1, m + 1, m - 1
 f_loop <- function(){
   while(df_ab[nrow(df_ab),"n"]!=0 & df_ab[nrow(df_ab),"m"] !=0){
   v_rates <- c( 
     n_p = df_ab[nrow(df_ab),"n"] * beta_n,     # n+1
     n_m = df_ab[nrow(df_ab),"n"] * (delta_n +  # n-1
                                       (df_ab[nrow(df_ab),"n"]-1) * gamma_n/2 +
                                       C_n * df_ab[nrow(df_ab),"m"]),
     m_p = df_ab[nrow(df_ab),"m"] * beta_m,     # m+1
     m_m = df_ab[nrow(df_ab),"m"] *(delta_m +   # m-1
                                      (df_ab[nrow(df_ab),"m"]-1) * gamma_m/2 +  
                                      C_m * df_ab[nrow(df_ab),"n"]))
   v_Srates <- sum(v_rates)
   # update
   df_ab[nrow(df_ab)+1,] <- c(df_ab[nrow(df_ab),1:2] + df_t[sample(1:4,size = 1,prob=v_rates/v_Srates),],
                              df_ab[nrow(df_ab),"t"] - log(runif(1))/v_Srates)
   }
   return(df_ab)
}
df_dinamica <- plyr::rdply(.n = replicas,f_loop())
readr::write_csv(df_dinamica,file = path_csv)
}
```

    
```{r desenho expercimental invasão, eval=FALSE,echo=FALSE}
library(plyr)
library(doMC)
library(tidyverse)
df_sim <- data.frame(k = 50, beta = 0.7/365.25, delta = 0.69/365.25) |> 
  mutate(gamma = 2* (beta - delta) / k)
df_sim <- cbind(df_sim,
                expand.grid(M0 = floor(df_sim$k * c(0.05,seq(0.2,1,by=0.2))), # 
                            C_n = df_sim$gamma * seq(1,2,length.out=6))) |> 
  mutate(C_m = gamma)
df_sim <- rbind(filter(df_sim,C_n!=df_sim$gamma[1]),
                mutate(df_sim,
                       C_m=C_n,C_n=gamma)) |> 
  mutate(id = 1:n(),
         path = paste0("csv/id_",id,".csv"))

df_sim |> 
  mutate(M0_plot = M0/50,
         C_n.m = C_n - C_m,
         C_n.m_plot = C_n.m/gamma) |> 
  ggplot(aes(x=M0_plot,y=C_n.m_plot)) + 
  geom_hline(yintercept = 0,color="red",alpha=0.4) +
  geom_point() +
  labs(title = "Cenários Simulados",
       x="initial abundance m (%K = 50)",y=expression(C[n] - C[m]*"(%)"),
       subtitle = "n = resident specie, m = invader specie") +
  theme_bw()
```
  
__Figura 1__ Cenários simulados de competição interespecífica.  Eixo x: diferença no parâmetro C da espécie residente pela invasora, dividido pelo parâmetro $\gamma$.


```{r simulação do modelo nos cenários explorados, eval=FALSE,echo=FALSE,include=TRUE}
registerDoMC(3)
plyr::a_ply(df_sim,1,
            function(X) do.call("f_2sppSLV",
                                list(N0=X$k,beta_n=X$beta,delta_n=X$delta,gamma_n=X$gamma,C_n=X$C_n,
                                     M0=X$M0,beta_m=X$beta,delta_m=X$delta,gamma_m=X$gamma,C_m=X$C_m,
                                     replicas=50,path_csv=X$path)),
            .parallel = TRUE)
```


### anaĺise dos dados

```{r análises preparatórias, eval=FALSE, echo=FALSE, include=FALSE}
f_resultados <- function(X){
  read_csv(X$path) |>
    group_by(.n) |>
    slice_tail(n=1) |> 
    mutate(invasion=ifelse(m!=0,1,0))
}
registerDoMC(2)
df_rep.tFinal <- adply(df_sim,1,f_resultados,.parallel = TRUE)
df_resultados <- df_rep.tFinal |> 
  group_by(id) |>
  summarise(c_invasion = sum(invasion),
            t_mean = mean(t),
            t_var = var(t),
            n_mean = mean(n),
            n_var = var(n),
            m_mean = mean(m),
            m_var = var(m)) |> 
  inner_join(distinct(select(df_rep.tFinal,id:C_m)),by="id") |> 
  mutate(C_nm = (C_n - C_m)/df_sim$gamma[1]) |> 
  arrange(C_nm)
#
write_csv(df_rep.tFinal,file = "resultados/df_rep_tFinal.csv")
write_csv(df_resultados,file="resultados/df_resultados.csv")
```

```{r modelo estatístico para descrever a probabilidade de invasao,echo=FALSE,include=FALSE,eval=FALSE}
# pacote adicional
library(mgcv)
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_resultados.csv")
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# glm binomial
md_P.replacement <- gam(cbind(c_invasion,50-c_invasion) ~ s(M0.z,bs = "cr") + s(C_nm.z,bs = "cr") + ti(M0.z,C_nm.z,bs=c("cr","cr")),
                        family = binomial(link = logit),data = df_resultados)
summary(md_P.replacement)
```
```{r graf exp prob replace the resident, echo=FALSE,include=TRUE,eval=TRUE}
library(tidyverse)
df_resultados <- readr::read_csv("resultados/df_resultados.csv")
df_resultados |> 
  mutate(Prob_invasion = c_invasion/50,
         propM0 = M0/50) |> 
  ggplot(aes(x=propM0,y=C_nm,fill=Prob_invasion)) +
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  labs(fill="",x="M0, initial pop. size of invader (%K)",y="Cn - Cm (%)") +
  coord_cartesian(expand = FALSE) +
  # scale_y_continuous(breaks = seq(0,20,by=4)) +
  # scale_x_continuous(breaks = seq(0.05,0.95,by=0.10)) +
  ggtitle("Prob(replace the resident specie)") +
  theme_classic()
```

# Apêndice

```{r time estimative, include=FALSE,echo=FALSE,eval=FALSE}
f_2sppSLV(N0=50, beta_n = 0.7/365.25, delta_n = 0.69/365.25, gamma_n = (0.7/365.25 - 0.69/365.25)/50, C_n =  (0.7/365.25 - 0.69/365.25)/50,
          M0=50, beta_m = 0.7/365.25, delta_m = 0.69/365.25, gamma_m = (0.7/365.25 - 0.69/365.25)/50, C_m =  (0.7/365.25 - 0.69/365.25)/50,replicas = 50)
start_time <- Sys.time()
plyr::rdply(.n = 2,f_loop())
end_time <- Sys.time()
end_time - start_time
```



