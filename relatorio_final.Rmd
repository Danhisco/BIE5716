---
title: "Generalization of the stochastic logistic model to interspecific competition"
author: "Danilo Pereira Mori"
date: "2022-08-20"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,message = FALSE,warning = FALSE,cache = TRUE)
```

```{r pacotes, include=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
library(trackdown)
library(knitr)
library(kableExtra)
library(bbmle)
library(MuMIn)
library(AICcmodavg)
library(boot)
library(DHARMa)
library(lme4)
library(gridExtra)
library(deSolve)
library(doMC)
library(plyr)
library(tidyverse)
```



```{r google docs management, eval=FALSE,include=FALSE}
# library(trackdown)
# both overwrite: 
# overwrite the current google drive file with the current Rmd:
update_file(file ="relatorio_final.Rmd",
            gpath = "mestrado/disciplinas/BIE5716/",
            hide_code = TRUE)
# overwrite the current Rmd with the current google drive 
download_file(file ="relatorio_final.Rmd",
              gpath = "mestrado/disciplinas/BIE5716/")
```

# Introdução  
   
<p>O modelo de crescimento exponencial incorpora o princípio fundamental de que a vida provém de outra e assim examina o comportamento de uma população que pode crescer sem limitação alguma. Ao incluir a influência que o aumento na densidade populacional pode ter na limitação do crescimento, o modelo logístico incorpora outro princípio fundamental que é o da perda de excedente de indivíduos esperado por um crescimento ilimitado. Caso uma população crescesse de forma exponencial todo o universo conhecido poderia estar colonizado por um único tipo de vida. Outro componente essencial da modulação dos eventos demográficos é a interação com outras espécies, como competição interespecífica. </p>
<p>Os modelos de competição de populações em denso dependência do arcabouço de reações de difusão (estocásticos) diferem dos modelos baseados em taxas constantes (determinísticos), pois os eventos demográficos são representados como eventos probabilísticos que podem ou não ocorrer em intervalos de tempo muito pequenos. Dessa forma, os modelos estocásticos possibilitam eventos de extinção de populações que poderiam permanecer indefinidamente no predito determinístico; ou flutuações nos tamanhos populacionais, propriedade ausente nos modelos determinísticos de denso dependência linear. Os modelos estocásticos podem ser descritos por uma equação mestra, um conjunto de equações diferenciais de primeira ordem que descrevem como a probabilidade de todos os possíveis estados do sistema varia no tempo contínuo. A partir da equação mestra é possível calcular a equação diferencial do primeiro momento da distribuição de probabilidades do sistema. Usando a aproximação de campo médio, onde é pressuposto variância zero, a equação diferencial do primeiro momento converge para a solução determinística. Alternativamente à descrição de todos os estados do sistema, é possível simular trajetórias individuais no sistema com o algoritmo de Gillespie (1977), onde podemos acompanhar a trajetória da abundância de cada espécie até a extinção.</p>
<p>Aqui vamos explorar a competição de 2 populações em crescimento denso dependente, N e M, em cenários de invasão da espécie M no sistema dominado por N que se encontra em sua capacidade de suporte. Usando modelos estocásticos e a aproximação de campo médio, explorei cenários de assimetria competitiva e de tamanho inicial da espécie invasora. Me pergunto a) Como a probabilidade de substituição da espécie residente pela invasora varia com o tamanho populacional inicial da invasora e da assimetria competitiva? e b) Como a presença da espécie residente reduz o tempo de extinção da espécie invasora?</p>

# Métodos
    
## Reações  
  
<p>Vamos modelar a mudança de estado do sistema, descrito por (n,m), onde n e m são a abundância de N e M, respectivamente. O modelo considera possíveis mudanças discretas de 1 indivíduo no sistema em um intervalo de tempo muito pequeno dt. As oito reações consideradas estão disponíveis na tabela 1, elas constituem um modelo de denso dependência em que a competição interespecífica é modelada de forma similar à da competição intraespecífica: pela probabilidade de exclusão de um dos dois indivíduos por evento de colisão de dois indivíduos. O modelo pressupõe que não é possível distinguir entre indivíduos de uma mesma espécie, assim, o parâmetro $\gamma$ descreve a probabilidade de qualquer um dos dois indivíduos ser excluído, por isso ele está dividido por 2.</p>

```{r tabela 1}
df_tabela1 <- data.frame(reactions = c("n -> n + n","n -> 0","n + n -> n","n + m -> m",
                                       "m -> m + m","m -> 0","m + m -> m","m + n -> n"),
                         description = c("reprod. assex. de N","morte de N","comp. intraesp. de N","exclusão de N por M",
                                         "reprod. assex. de M","morte de M","comp. intraesp. de M","exclusão de M por N"),
                         Prob_dt = c("$\\beta n$","$\\delta n$","$\\gamma n (n-1) 2^{-1}$","$\\text{C}_{n} n m$",
                                     "$\\beta m$","$\\delta m$","$\\gamma m (m-1) 2^{-1}$","$\\text{C}_{m} m n$"),
                         unit_ParDemog = c("$P(nasc. de N)/ind. de N  dt$", "$P(morte de N)/ind. de N dt$",
                                           "$P(exclusão de N)/colisão N dt$","$P(exclusão de N)/colisão N M dt$",
                                           "$P(nasc. de M)/ind. de M dt$", "$P(morte de M)/ind. de M dt$",
                                           "$P(exclusão de M)/colisão M dt$","$P(exclusão de M)/colisão M N dt$"))
df_tabela1 %>%
  kbl(caption = "Tabela 1. Possíveis reações no modelo estocástico de competição de duas espécies sob denso dependência",
      col.names = c("reações","descrição","P(reação)/dt","unidade do parâmetro")) %>%
  kable_classic(full_width = T, html_font = "Cambria")

```
  
## The master equation and the mean-field approximation      
     
<p>A partir das reações é possível desenvolver uma equação mestra que descreve a taxa de mudança da probabilidade de um determinado estado [$\frac{\partial P(n,m,t)}{\partial t}$] pela diferença na taxa da probabilidade de entrada e saída deste estado (equação 1). Na primeira linha depois da igualdade, há a soma das taxa com que N pode perder um indivíduo, indo do estado (n+1,m) para o estado (n,m). Na segunda linha a taxa com que N pode ganhar um indivíduo, indo do estado (n-1,m) para o estado (n,m). Nas linhas 3 e 4 a mesma lógica para M. Na quinta linha há a taxa de saída do estado (n,m). Para detalhes veja tabela 1.</p>

$$
\frac{\partial P(n,m,t)}{\partial t} = \\
P(n+1,m) (n+1) (\delta_n + n \gamma_n / 2 + m C_{n}) +\\ P(n-1,m) (n-1) \beta_n+\\ 
P(n,m+1) (m+1) (\delta_m + m \gamma_m / 2 + n C_{m}) +\\ P(n,m-1) (m-1) \beta_m+\\
- P(n,m)[n(\beta_n + \delta_n + (n-1) \gamma_n / 2 + m C_{n}) + m(\beta_m + \delta_m + (m-1) \gamma_m / 2 + n C_{m})]
$$

<p>Na aproximação de campo médio buscamos obter o primeiro momento da distribuição de probabilidade marginal de N, E[N] = <n>, e de M, E[M] = <m>. Para isso é necessário estabelecer algumas definições: $<n> = \sum_{n=0}^{\infty} n P(n,m,t)$; $<n^2> = \sum_{n=0}^{\infty} n^2 P(n,m,t)$; $<m> = \sum_{m=0}^{\infty} m P(n,m,t)$; $<m^2> = \sum_{m=0}^{\infty} m^2 P(n,m,t)$; $<nm> = \sum_{n=0}^{\infty}\sum_{m=0}^{\infty} nm P(n,m,t)$. Para obter o primeiro momento marginal de N ou M basta multiplicar a equação mestra por n ou m e realizar o somatório (apêndice 1), e então é possível obter as equações 2a e 2b:</p>

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n^2>\gamma_n2^{-1} - <nm>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m^2>\gamma_m2^{-1} - <mn>C_m
$$

<p>A aproximação de campo médio pressupõe que $<n>^2 = <n^2>$, $<m>^2 = <m^2>$, $<nm> = <n><m>$. Esse pressuposto implica que a variância da dinâmica populacional denso dependente é zero e que as populações são independentes. Outro pressuposto possível para simplificar a aproximação é de que $\beta$ ou $\delta$ >> $\gamma$, assim $\gamma$ pode ser omitido como fator do primeiro momento. Essa aproximação é útil pois permite a convergência das equações acima com o modelo determinístico de competição interespecífica de duas populações com crescimento denso dependente (eq. 3a e 3b). </p>

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n)- <n>^2\gamma_n2^{-1} - <n><m>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m)- <m>^2\gamma_m2^{-1} - <m><n>C_m
$$
<p> A investigação desse modelo determinístico no equilíbrio mostra o quê poderíamos esperar no longo prazo caso não houvesse nenhuma flutuação devido à estocástica dos eventos demográficos. No espaço de fase definido pela abundância da espécie residente, no eixo x, e da invasora, eixo y, a isolinha descreve as combinações de tamanhos populacionais onde o crescimento populacional da espécie focal é zero. Para explorar os cenários determinísticos no equilíbrio é possível expressar as duas isolinhas em função da abundância da invasora (eq. 4a e 4b e figura 1).</p>


$$
<m> = \frac{\beta_n - \delta_n}{C_n} - \frac{<n'>\gamma_n}{2C_n} 
$$
$$
<m'> = \frac{2(\beta_m - \delta_m)}{\gamma_m} - \frac{2C_m<n>}{\gamma_m} 
$$





## The computational model
´
<p>A ideia do algoritmo de Gillespie (1977) se baseia no fato de que a distribuição de tempos entre mudanças de estados pode ser descrita por uma distribuição exponencial, então computamos separadamente as mudanças de estado e o tempo entre mudanças, reduzindo o tempo de simulação.  O tempo entre mudança de estados pode ser obtido pela divisão do log de uma amostra de distribuição uniforme padrão pela soma das taxas de saída do estado (janela de código 1). Existem 4 possíveis transições de estado: cada uma das duas espécies pode ganhar ou perder um indivíduo por evento demográfico no intervalo de tempo dt. A taxa de ganho de um indivíduo de N ($n\_p$) é  $n\_p=\beta n$. A taxa de perda de um indivíduo de N ($n\_m$) é $n\_m = n[\delta +(n-1)\gamma2^{-1} + mC_n]$. A mesma lógica se aplica para as taxas de ganho e perda da espécie M (eq. 1 e janela de código 1). Após o sorteio do tempo do próximo evento demográfico, é feito um sorteio da mudança de estado com probabilidade dada pela contribuição relativa de cada taxa de saída (janela de código 1), então o sistema é atualizado. Nossa simulação termina quando a espécie invasora atinge a abundância zero.</p>

__janela de código 1__

```{r the computacional model,echo=TRUE,eval=TRUE}
f_2sppSLV <- function(N0,beta_n,delta_n,gamma_n,C_n,
                      M0,beta_m,delta_m,gamma_m,C_m,
                      replicas,path_csv){
 df_ab <- data.frame(n=N0,m=M0,t=0)
 df_t <- data.frame(n=c(1,-1,0,0), # 4 possibles transitions:
                    m=c(0,0,1,-1)) # n + 1, n - 1, m + 1, m - 1
 f_loop <- function(){
   while(df_ab[nrow(df_ab),"m"] !=0){
   v_rates <- c( 
     n_p = df_ab[nrow(df_ab),"n"] * beta_n,     # n+1
     n_m = df_ab[nrow(df_ab),"n"] * (delta_n +  # n-1
                                       (df_ab[nrow(df_ab),"n"]-1) * gamma_n/2 +
                                       C_n * df_ab[nrow(df_ab),"m"]),
     m_p = df_ab[nrow(df_ab),"m"] * beta_m,     # m+1
     m_m = df_ab[nrow(df_ab),"m"] *(delta_m +   # m-1
                                      (df_ab[nrow(df_ab),"m"]-1) * gamma_m/2 +  
                                      C_m * df_ab[nrow(df_ab),"n"]))
   v_Srates <- sum(v_rates)
   # update
   df_ab[nrow(df_ab)+1,] <- c(df_ab[nrow(df_ab),1:2] + df_t[sample(1:4,size = 1,prob=v_rates/v_Srates),],
                              df_ab[nrow(df_ab),"t"] - log(runif(1))/v_Srates)
   }
   return(df_ab)
}
df_dinamica <- plyr::rdply(.n = replicas,f_loop())
readr::write_csv(df_dinamica,file = path_csv)
}
```
  

## Cenários de assimetria competitiva e tamanho inicial da invasora
  
<p>Apenas o parâmetro que descreve a probabilidade de exclusão de uma espécie pela outra por colisão (parâmetros $C_n$ e $C_m$, tabela 1) variou entre simulações. Os demais parâmetros populacionais foram iguais: $\beta =$ `r format(0.7/365.25,scientific = TRUE,digits = 4)`, $\delta =$ `r format(0.69/365.25,scientific = TRUE,digits = 4)`, $\gamma =$ `r format(2*(0.7/365.25-0.69/365.25)/50,scientific = TRUE,digits = 4)`. Os parâmetros de competição interespecífica ($C_n$ e $C_m$) variam entre $\gamma/4$ e $\gamma/2$, tal que a assimetria competitiva, definido por $2(C_n - C_m)/ \gamma$, variou entre -0.5 e 0.5 (figura 1). O tamanho inicial da espécie invasora variou entre 1% e 100% da capacidade de suporte K = 50 indivíduos (Figura 1a). Foram simulados 11 cenários de tamanho inicial da invasora e 11 cenários de assimetria competitiva, totalizando 121 cenários, cada um com 100 réplicas. Quando a assimetria é nula então o sistema é indeterminado; se ela for maior do que zero então, dado tempo suficiente, a espécie invasora irá dominar o sistema; se a assimetria é negativa, então a residente dominará o sistema (Figura 1b) </p> 




```{r graficos dos cenarios simulados, echo=FALSE,eval=TRUE,fig.width=8,fig.height=4}
# dados completo
df_sim0 <- data.frame(k = 50, beta = 0.7/365.25, delta = 0.69/365.25) |> 
  mutate(gamma = 2 * (beta - delta) / k)
df_sim0 <- cbind(df_sim0,
                 expand.grid(M0 = floor(df_sim0$k * c(0.05,seq(0.1,1,by=0.1))),
                             C_n = (df_sim0$gamma/2) * seq(0.50,1,length.out=6))) |> 
  mutate(C_m = gamma/2)
df_sim0 <- rbind(filter(df_sim0,C_n!=(df_sim0$gamma[1]/2)),
                 mutate(df_sim0,
                        C_m=C_n,C_n=gamma/2)) |> 
  mutate(C_nm = ((C_n - C_m)*2)/gamma) %>% 
  arrange(M0,C_nm) %>% 
  dplyr::mutate(id = 1:n(),
         path = paste0("csv/md_Estocastico/id_",id,".csv"))
write_csv(df_sim0,file = "csv/df_sim0.csv")
df_sim0 <- df_sim0 |> 
  select(-path)
# gráficos
l_p <- list()
## cenários simluados
l_p[[1]] <- df_sim0 |> 
  mutate(M0_plot = M0/50) |> 
  ggplot(aes(x=M0_plot,y=C_nm)) + 
  geom_hline(yintercept = 0,color="red",alpha=0.4) +
  geom_point() +
  labs(title = "a) Cenários Simulados",
       x="initial abundance m (%K = 50)",y=expression((C[n] - C[m])*2/gamma),
       subtitle = "n = resident specie, m = invader specie") +
  theme_bw()
## isolinhas das espécies no espaço de fase definido por elas
df_plot <- df_sim0 |> filter(C_nm %in% c(-0.5,0,0.5) & M0==2) |>  select(-M0)
beta = df_sim0$beta[1]
delta = df_sim0$delta[1]
gamma = df_sim0$gamma[1]
# equação 4a
f_IsoResidente <- function(x,C_n) (beta - delta) / C_n - x * gamma/(2*C_n)
f_IsoInvasora <- function(x,C_m) 2*(beta - delta)/gamma - 2*C_m*x/gamma
# curve(f_IsoResidente(x,C_n=df_plot$C_n[1]),from = 0,to = 50)
df_plot <- left_join(x=data.frame(x=rep(0:50,3),id = rep(c(1,6,11),each=51)),
                     y=df_plot,
                     by="id") |> 
  select(-id,-k) |> 
  mutate(n = f_IsoResidente(x=x,C_n=C_n),
         m = f_IsoInvasora(x=x,C_m=C_m))
l_p[[2]] <- df_plot |> 
  pivot_longer(cols = c("n", "m"),
               names_to = "species",
               values_to = "N") |> 
  mutate(C_nm = factor(C_nm,levels = c(0.5,0,-0.5)),
         species = factor(species,levels = c("n","m"))) |>
  ggplot(aes(x=x,y=N,color=species)) +
  geom_line(alpha=0.5,size=1.2) + 
  ylim(0,50) + 
  xlim(0,50) +
  scale_color_manual(labels = c("n", "m"),
                     values = c("blue", "red")) +
  coord_cartesian(expand = FALSE) +
  labs(x="n",y="m",color="",title="b) Isolinhas Campo Médio") +
  theme_bw() + theme(legend.position="right") +
  facet_wrap(~C_nm,ncol=1)
grid.arrange(grobs=l_p,ncol=2,layout_matrix=matrix(c(1,1,1,1,2,2),nrow=1))
```
  
__Figura 1__ Cenários simulados de competição interespecífica.  Eixo y: assimetria competitiva -  a diferença no parâmetro C da espécie residente pela invasora, dividido pelo parâmetro $\gamma$. Eixo x: tamanhos iniciais da espécie invasora de 1% até 100%.
 



### anaĺise dos dados

<p>Para responder a primeira pergunta, como a probabilidade de substituição da residente varia em função do tamanho inicial da invasora e da assimetria competitiva, é possível usar a abordagem de campo médio e a de simulação de trajetórias individuais. No caso da abordagem de campo médio, exceto pelo cenário de equivalência das espécies (assimetria competitiva nula) que depende totalmente das condições iniciais e do regime de perturbações, dado tempo suficiente haverá certamente a substituição ou a não substituição da espécie residente pela invasora, em função da assimetria competitiva a favor da invasora ou da residente, respectivamente. Nessa abordagem basta plotar as soluções de equilíbrio das equações 3a e 3b em um plano de fase definido pelas abundância de N e M para avaliar qual o ponto de equilíbrio estável para definir se haverá ou não evento de substituição. No caso da simulação de trajetórias individuais, considerei a identidade da espécie que permanece após a primeira extinção. Se a espécie que permanece é a invasora então ocorreu um evento de substituição da residente pela invasora. Para descrever a probabilidade de substituição na simulação das trajetórias indivíduais usei um GLM binomial com o tamanho inicial da invasora e a assimetria competitiva como variáveis preditoras. Usei uma abordagem baseada em modelo médio (REF), em que a partir de um modelo cheio é ajustado todos os possíveis submodelos e então a predição de cada modelo é ponderada pelo peso de evidência do submodelo. O GLM binomial cheio considerou a interação do polinômio de segundo grau de cada preditora.</p>
<p>Para responder a segunda pergunta, como a presença da residente reduz o tempo de extinção da invasora, é necessário descrever o tempo de extinção da invasora nas simulações de trajetórias individuais em duas situações. A primeira situação é obtida pela análise da distribuição de tempos de extinção da invasora na presença da competidora, ou seja, os tempos totais até a espécie invasora se extinguir, seja ela a primeira ou última a se extinguir. Essa primeira situação pode ser descrita por um LMM em que os tempos de extinção de réplicas de uma mesma bateria de simulação (combinação única de tamanho inicial e assimetria competitiva) são agrupadas na estrutura aleatória (REF), e então usei as mesmas preditoras do GLM binomial para construir um modelo cheio. Na segunda situação considerei apenas o tempo parcial de extinção na ausência da residente, ou seja, considerei que o tempo é zerado no momento do evento de substituição. Para descrever a segunda situação é possível usar um LM em que o modelo cheio é composto pelo polinômio de segundo grau do tamanho da espécie invasora no momento do evento de substituição. Em ambas situações usei uma abordagem de modelo médio para construir o predito para os tempos de extinção. Então calculei a diferença no predito pelo modelo médio na segunda situação pela primeira situação.</p>

# Resultados


#### Como a probabilidade de substituição varia com o tamanho inicial da invasora e a assimetria competitiva?

  
```{r figura 2 Probabilidade de substituicao da residente pela invasora}
# dados
df_resultados <- read_csv(file="resultados/df_tFinal.csv")
df_plot <- read_csv(file="resultados/df_GLMBin_modavg.csv")
# graficos
max_fill <- max(c(df_plot$mod.avg.pred,df_resultados$c_invasion/100,
                  df_plot$lower.CL,df_plot$upper.CL)) + min(df_resultados$c_invasion/100)
l_p <- list()
v_breaks <- c(as.numeric(round(quantile(df_plot$mod.avg.pred,probs = seq(0.10,0.50,length=5)),digits = 2)),max_fill/2)
l_p[[1]] <- ggplot(mutate(df_plot,label="Average"),
                   aes(x=M0,y=C_nm,fill=mod.avg.pred)) +
  geom_tile() +
  # geom_contour(aes(z=mod.avg.pred),alpha=0.2, colour="black",
  #              breaks = v_breaks) +
  # metR::geom_text_contour(aes(z=mod.avg.pred),stroke=0.05,
  #                         breaks = v_breaks) +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Prob. replacement",
       fill="Probability") +
  coord_cartesian(expand = FALSE) +
  facet_wrap(~label) +
  theme_classic()
l_p[[2]] <- ggplot(df_plot,aes(x=M0,y=C_nm,fill=lower.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Lower IC (5%)",
       fill="Probability") + theme_classic()
l_p[[3]] <- ggplot(df_plot,aes(x=M0,y=C_nm,fill=upper.CL)) +
  geom_tile() +
  scale_fill_gradient2(limits = c(0,max_fill),midpoint=max_fill/2, low="red", high="blue",mid="green") +
  labs(title="Upper IC (95%)",
       fill="Probability") + theme_classic()
grid.arrange(grobs=l_p,
             layout_matrix=rbind(rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 rep(1,4),
                                 c(2,2,3,3),
                                 c(2,2,3,3))
             )

```
  
  
__Figura 2__ Gráfico Exploratório da Probabilidade da espécie invasora substituir a espécie residente em função da assimetria competitiva (eixo y) e tamanho populacional inicial da espécie invasora (eixo x).  

## Como a presença da residente reduz o tempo de extinção da invasora?

```{r figura 3}
# preparação dos dados
## df_plot_2spp
df_plot_2spp <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5))
df_plot_2spp <- left_join(df_plot_2spp,
                      ddply(df_plot_2spp,"M0",summarise,avg_logTE = mean(log_TE),sd_logTE = sd(log_TE)),
                      by="M0")
### df_plot_1spp
df_plot_1spp <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> 
  arrange(M0) |> 
  filter(M0 %in% unique(df_plot_2spp$M0))
df_plot_1spp <- left_join(df_plot_1spp,
                          ddply(df_plot_1spp,"M0",summarise,avg_logTE = mean(log_TE),sd_logTE = sd(log_TE)),
                          by="M0") |> 
  select(M0,mod.avg.pred:sd_logTE) |> 
  distinct()
names(df_plot_1spp)[-1] <- paste0(names(df_plot_1spp)[-1],"_1sp") 
### df_plot
df_plot <- left_join(df_plot_2spp,df_plot_1spp,by="M0")
# gráficos
df_plot |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  geom_ribbon(aes(ymin=lower.CL_exp_1sp,ymax=upper.CL_exp_1sp),alpha=0.5,color="blue",fill="blue",alpha=0.5) +
  geom_line(aes(y=mod.avg.pred_exp_1sp),color="blue",alpha=0.5) +
  labs(y="Tempo Extinção (anos)",x="Tamanho inicial invasora") +
  facet_wrap(~C_nm,ncol=3)
```



 # Discussão





<!-- #################################################################### -->
<!-- #################################################################### -->
Uma expectativa é que a probabilidade da espécie invasora substituir a espécie residente deve aumentar quanto maior o tamanho populacional inicial da invasora e maior a assimetria competitiva em favor da invasora. 
Com a intenção de avaliar se é possível ter alguma intuição sobre o comportamento do sistema estocástico a partir da aproximação de campo médio, me pergunto como o predito determinístico diverge do observado em uma série de simulações individuais do processo estocástico. 
Pois, quanto menor o tamanho populacional maior a chance de uma sequência de eventos demográficos leve à extinção da invasora, mesmo quando dominante. E quanto maior a assimetria competitiva em favor da invasora, maior a probabilidade da espécie residente reduzir em abundância por possível evento demográfico.
<!-- #################################################################### -->
<!-- ####################################################################  -->
 

# Apêndice

<!-- ## Códigos para rodar as simulações estocasticas e deterministicas -->

```{r time estimative, include=FALSE,echo=FALSE,eval=FALSE}
f_2sppSLV(N0=50, beta_n = 0.7/365.25, delta_n = 0.69/365.25, gamma_n = (0.7/365.25 - 0.69/365.25)/50, C_n =  (0.7/365.25 - 0.69/365.25)/50,
          M0=50, beta_m = 0.7/365.25, delta_m = 0.69/365.25, gamma_m = (0.7/365.25 - 0.69/365.25)/50, C_m =  (0.7/365.25 - 0.69/365.25)/50,replicas = 50)
start_time <- Sys.time()
plyr::rdply(.n = 2,f_loop())
end_time <- Sys.time()
end_time - start_time
```


```{r simulação do modelo estocastico, eval=FALSE,echo=FALSE,include=TRUE}
registerDoMC(3)
plyr::a_ply(df_sim,1,
            function(X) do.call("f_2sppSLV",
                                list(N0=X$k,beta_n=X$beta,delta_n=X$delta,gamma_n=X$gamma,C_n=X$C_n,
                                     M0=X$M0,beta_m=X$beta,delta_m=X$delta,gamma_m=X$gamma,C_m=X$C_m,
                                     replicas=50,path_csv=X$path)),
            .parallel = TRUE)
```

<!-- ### the mean field approximation -->

```{r modelo deterministico,eval=FALSE,include=FALSE,echo=FALSE}
f_2sppDLV <- function(X,max_t,int_t,path_csv){
 f_ode<- function(t,y,p){
   N <- y[1]
   M <- y[2]
   with(as.list(p),{
     dNdt <- (beta - delta)*N - gamma*(N^2)/2 - C_n*N*M
     dMdt <- (beta - delta)*M - gamma*(M^2)/2 - C_m*M*N
     return(list(c(dNdt,dMdt)))
   })
   }
 p <- unlist(select(X,beta:gamma,C_n:C_m))
 y0 <- unlist(X[,c("k","M0")])
 names(y0) <- c("N","M")
 times <- seq(0,max_t,int_t)
 df_ab.det <- ode(y=y0,times = times,func = f_ode,parms = p)
 df_ab.det <- as.data.frame(df_ab.det)
 readr::write_csv(x = df_ab.det,file=path_csv)
}
```

```{r simulacao do modelo deterministico,echo=FALSE,eval=FALSE}
# resultados dos modelos estocasticos
df_resultados <- read_csv(file = "resultados/df_resultados.csv") |> 
  mutate(t_max_anos = t_max/365.25)
# df_resultados$t_max_anos |> summary()
# df par simulações
df_sim2 <- inner_join(df_sim0,
                      select(df_resultados,id,t_max_anos),
                      by="id") |> 
  mutate(path=paste0("csv/md_CampoMedio/id_",id,".csv"))
# simulação
# X <- df_sim2[1,]
intervalo_EulerMethod <- 0.02
registerDoMC(3)
plyr::a_ply(df_sim2,1,
            function(df) f_2sppDLV(X=df, 
                                   max_t = (df$t_max_anos+10*intervalo_EulerMethod),
                                   int_t = intervalo_EulerMethod,path_csv = df$path),
            .parallel = TRUE)
```
  
    
<!-- ## Cálculo das métricas de avaliação   -->


<!-- ### Contagem de eventos de substituição  -->
    
      
```{r análises preparatórias 1 - df_resultados e df_replicas, eval=FALSE, echo=FALSE, include=FALSE}
df_sim <- read_csv("csv/df_sim0.csv")
f_resultados <- function(X){
  df <- read_csv(X$path)
  read_csv(X$path) |>
    group_by(.n) |>
    slice_tail(n=1) |>
    mutate(invasion=ifelse(m==0 & n==0,1,0))
}
registerDoMC(3)
df_rep.tFinal <- adply(df_sim,1,f_resultados,.parallel = TRUE)
write_csv(df_rep.tFinal,file="resultados/df_rep_tFinal.csv")
######
df_tFinal <- df_rep.tFinal |> 
  group_by(id) |>
  summarise(c_invasion = sum(invasion),
            t_mean = mean(t),
            t_var = var(t),
            t_max = max(t),
            n_mean = mean(n),
            n_var = var(n)) |> 
  inner_join(distinct(select(df_rep.tFinal,id:M0)),by="id") |> 
  mutate(C_nm = (C_n - C_m)*2/df_sim$gamma[1]) |> 
  arrange(C_nm)
write_csv(df_tFinal,file = "resultados/df_tFinal.csv")
# df_resResidente
# df <- df_rep.tFinal |> filter(id==1)
f_TEres <- function(df){
  df_ab <- read_csv(df$path[1]) |> 
    filter(.n %in% unique(df$.n[df$invasion==1]))
  df_ab[df_ab$n==0,] |> group_by(.n) |> slice_head()
}
registerDoMC(3)
df_res0 <- ddply(df_rep.tFinal,"id",f_TEres,.parallel = TRUE)
df_tParcial <- left_join(rename(df_res0,TE_res=t),
                         select(filter(df_rep.tFinal,invasion==1),id,.n,M0,C_nm,t),
                         by=c("id",".n")) |> 
  mutate(TE_1sp = t - TE_res)
write_csv(df_tParcial,file = "resultados/df_tParcial.csv")
```

  
## Modelos estatísticos

### Probabilidade de substituição da residente pela invasora

```{r graf exp prob replace the resident, echo=FALSE,include=TRUE,eval=TRUE}
df_resultados <- readr::read_csv("resultados/df_tFinal.csv")
df_resultados <- df_resultados |> 
  mutate(Prob_invasion = c_invasion/100,
         propM0 = M0/50,
         t_sd=sqrt(t_var))
df_resultados |> 
  ggplot(aes(x=propM0,y=C_nm,fill=Prob_invasion)) +
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  labs(fill="",x="M0, initial pop. size of invader (%K)",y="(Cn - Cm) 2 / gamma") +
  coord_cartesian(expand = FALSE) +
  geom_text(aes(label=Prob_invasion)) +
  ggtitle("Proporção de eventos de substituição da residente em 100 réplicas") +
  theme_classic()
```

__Figura A1__ Proporção observada de substituições 


O modelo cheio mais plausível é aquele que considera a interação entre os polinômios (Tabela 1). Porêm este modelo não apresenta um excelente ajuste aos dados (Figura SI 1 e sumário do módelo 1). O predito e observado diferem em valores extremos: quando a proporção de substituições é baixa, o predito pode subestimar a probabilidade de substituição (Figura SI 2); quando a proporção é alta, o predito pode superestimar a probabilidade. Para as análises utilizei os pacotes DHARMa (REF), MuMIn (REF) e AICcmodavg (REF).


__tabela A1__ seleção de GLM Binomial Cheio para descrever a probabilidade de substituição

```{r modelo estatístico para descrever a probabilidade de invasao,echo=FALSE,include=FALSE,eval=TRUE}
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# glm binomial
l_md <- list()
l_md[[1]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[2]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[3]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[4]] <- glm(cbind(c_invasion,100-c_invasion) ~ (M0.z + I(M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[5]] <- glm(cbind(c_invasion,100-c_invasion) ~ 1,
                 family = "binomial",data=df_resultados)
l_md[[6]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[7]] <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
l_md[[8]] <- glm(cbind(c_invasion,100-c_invasion) ~ (log_M0.z + I(log_M0.z^2)),
                 family = "binomial",data=df_resultados)
names(l_md) <- c("C_nm^2 * M0^2","C_nm^2 + M0^2","C_nm^2","M0^2","1","C_nm^2 * log_M0^2","C_nm^2 + log_M0^2","log_M0^2")
AICctab(l_md,weights=TRUE)
```

 
```{r graficos diagnostico do GLM binomial mais plausível,include=TRUE,eval=TRUE}
res.Dharma <- DHARMa::simulateResiduals(l_md[["C_nm^2 + log_M0^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```
    
__Figura A2__ Resíduos Quantílicos GLM Binomial cheio. Resíduos quantílícos obtidos com a função simulateResiduals do pacote DHARMa, com 250 simulações.  
  

__tabela A2__ Sumário do modelo 1: GLM Binomial Cheio  

```{r sumário do GLM binomial cheio}
summary(l_md[["C_nm^2 + log_M0^2"]])
```

    
#### Modelo Médio
  
    
```{r construcao do modelo medio GLM Binomial,eval=FALSE,echo=FALSE}
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# modelo referência
md_ref <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)) + (log_M0.z + I(log_M0.z^2)),
              family = "binomial",data=df_resultados,na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for new data predictions
df_pred <- expand.grid(M0=seq(min(df_resultados$M0),max(df_resultados$M0),length=60),
                       C_nm.z=seq(min(df_resultados$C_nm.z),max(df_resultados$C_nm.z),length=60)) |> 
  mutate(log_M0 = log(M0))
df_pred$log_M0.z <- f_z(df_pred$log_M0)
# esse demora com esse tanto de pontos
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_pred,type="link") %>%
  cbind(df_pred)
df_GLMBin_modavg <- df_AICcmodavg |> 
  select(mod.avg.pred,lower.CL,upper.CL,C_nm.z) |> 
  mutate(C_nm = C_nm.z*sd(df_resultados$C_nm) + mean(df_resultados$C_nm),
         across(mod.avg.pred:upper.CL,arm::invlogit))
df_GLMBin_modavg$M0 <- df_AICcmodavg$M0
write_csv(df_GLMBin_modavg, file="resultados/df_GLMBin_modavg.csv")
```
  
    
```{r glm binomial observado e predito modelo medio, echo=F, comment=FALSE, message=FALSE,warning=FALSE,results="hide"}
# dados
df_resultados <- read_csv("resultados/df_tFinal.csv") |> 
  mutate(log_M0 = log(M0))
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$log_M0.z <- f_z(df_resultados$log_M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# modelo referência
md_ref <- glm(cbind(c_invasion,100-c_invasion) ~ (C_nm.z + I(C_nm.z^2)) + (log_M0.z + I(log_M0.z^2)),
              family = "binomial",data=df_resultados,na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for the observed data
mdAvg_MuMIn <- model.avg(l_dredge_nInvasions)
# Predição
df_md <- df_resultados
# interval = 'confidence' ainda não é usado, apenas para uma avaliação visual
df_md$Pr_invasion <- predict(mdAvg_MuMIn,type="response")*100
# Gráfico
colors <- c("loess" = "blue", "1 : 1" = "black")
ggplot(df_md,aes(x=c_invasion,y=Pr_invasion)) +
  geom_smooth(aes(color="loess"),method = "loess",formula = "y~0+x") +
  geom_abline(aes(color="1 : 1"),slope=1,intercept = 0) +
  geom_point() + 
  labs(x="número de substituições",
       y="predito pelo modelo médio",
       title="Predito pelo modelo médio X Observado",
       color = "") +
  scale_color_manual(values = colors)
```
    
__Figura A3__ predito pelo modelo médio e observado.   

### Tempo de Extinção

#### Tempo para extinção na ausência de competidora

```{r analise dos dados de tempo de extincao conjunto completo, fig.height=5,fig.width=8}
df_1sp <- read_csv(file="resultados/df_tParcial.csv") |> 
  dplyr::select(-M0,-(id:n),-(TE_res:t)) |> 
  dplyr::rename(M0 = m) |> 
  dplyr::mutate(TE = TE_1sp/365.25,
         log_TE = log(TE),
         log_M0 = log(M0))
l_p <- list()
l_p[[1]] <- df_1sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_1sp |> 
  pivot_longer(cols=c("M0","log_M0"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x="",y=valores)) +
  geom_jitter(alpha=0.2) +
  geom_boxplot() +
  facet_wrap(~variaveis,scales="free")
l_p[[3]] <- df_1sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_1sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Conjunto Completo")
```
```{r analise dos dados de tempo de extincao conjunto M0 menor ou igual 50, fig.height=5,fig.width=8}
df_1sp <- df_1sp |> filter(M0<=50 & M0>1)
l_p <- list()
l_p[[1]] <- df_1sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_1sp |> 
  pivot_longer(cols=c("M0","log_M0"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x="",y=valores)) +
  geom_jitter(alpha=0.2) +
  geom_boxplot() +
  facet_wrap(~variaveis,scales="free")
l_p[[3]] <- df_1sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_1sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Conjunto Parcial: 50 >= tamanho inicial > 1")
```

__Figura A4__ Conjunto de dados completo do Tempo estimado de extinção na ausência da competidora 

##### Ajuste modelo cheio LM TE 1sp

__Tabela A6__ Tabela seleção do modelo referência para descrever o log(Tempo de Extinção).  


```{r ajuste modelo cheio lm TE 1sp 1 }
# modelos
l_md <- list()
l_md[[1]] <- glm(TE ~ M0 + I(M0^2),data = df_1sp,Gamma(log))
l_md[[2]] <- glm(TE ~ M0,data = df_1sp,Gamma(log))
l_md[[3]] <- glm(TE ~ log_M0 + I(log_M0^2),data = df_1sp,Gamma(log))
l_md[[4]] <- glm(TE ~ log_M0,data = df_1sp,Gamma(log))
l_md[[5]] <- glm(TE ~ 1,data = df_1sp,Gamma(log))
names(l_md) <- c("M0^2","M0","log(M0)^2","log(M0)","1")
AICctab(l_md,weights=TRUE)
```

```{r graficos diagnostico do LM referencia TE 1sp 1 ,include=TRUE,eval=TRUE}
res.Dharma <- DHARMa::simulateResiduals(l_md[["log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```
    
__Figura A5__ Resíduos Quantílicos LM referência para descrever o tempo de extinção na ausência de residente. Resíduos quantílícos obtidos com a função simulateResiduals do pacote DHARMa, com 250 simulações.  
  

__tabela A6__ Sumário do modelo 2: LM referência polinômio de segundo grau

```{r sumário do LM referencia do tempo de extincao na ausencia da residente 1 }
summary(l_md[["log(M0)^2"]])
print("MASS::gamma.shape return:")
MASS::gamma.shape(l_md[["log(M0)^2"]])
```

```{r graficos diagnostico padrao log lm TE 1sp,include=FALSE}
par(mfrow=c(2,2))
plot(l_md[["log(M0)^2"]])
```


###### Modelo Médio


```{r lm log(TE) logM0 1sp modelo medio MUMIN,include=FALSE}
# modelo referência
md_ref <- glm(TE ~ log_M0 + I(log_M0^2),data = df_1sp, na.action = "na.fail",Gamma(log))
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# Model Averaging for the observed data
mdAvg_MuMIn <- model.avg(l_dredge_nInvasions)
# Model Averaging for new data predictions
# Predição
df_md <- df_1sp
df_md$log_TE_predict <- predict(mdAvg_MuMIn,type="link")
# Gráfico
colors <- c("loess" = "blue", "1 : 1" = "black")
ggplot(df_md,aes(x=log_TE,y=log_TE_predict)) +
  geom_point(alpha=0.3) + 
  geom_smooth(aes(color="loess"),method = "loess",formula = "y~x",se=FALSE) +
  geom_abline(aes(color="1 : 1"),slope=1,intercept = 0,size=2) +
  labs(x="observado",
       y="predito",
       title="log(TE) ~ log(M0)^2: Predito pelo modelo médio X Observado",
       color = "") +
  scale_color_manual(values = colors)
```



```{r TE single specie, eval=FALSE}
# modelo referência
md_ref <- glm(TE ~ log_M0 + I(log_M0^2),data = df_1sp, na.action = "na.fail",Gamma(log))
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# model averaging prediction
v_gamma.shape = MASS::gamma.dispersion(md_ref)
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_1sp,type="link",gamdisp=v_gamma.shape) %>%
  cbind(df_1sp) |> 
  select(TE,log_TE,M0,log_M0,mod.avg.pred,lower.CL,upper.CL) |>
  mutate(across(mod.avg.pred:upper.CL,exp,.names="{.col}_exp"))
write_csv(df_AICcmodavg,file = "resultados/df_GLMGamma_modavg_1sp.csv")
```
```{r graficos glm gamma log TE 1sp,echo=FALSE,fig.width=10,fig.height=5}
df_AICcmodavg <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> arrange(M0)
l_p <- list()
l_p[[1]] <- df_AICcmodavg |> 
  mutate(label = "y: escala função de ligação; x: escala preditora do GLM") |> 
  ggplot(aes(x=log_M0,y=log_TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL,ymax=upper.CL),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred)) +
  labs(y="log(TE)",x="log(M0)") +
  facet_wrap(~label)
l_p[[2]] <- df_AICcmodavg |> 
  mutate(label = "y e x: escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  labs(y="TE (anos)",x="M0 (indivíduos)") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Observado e Predito pelo GLM Gamma(log)")
```
 
  
__Figura A6__ Observado e predito GLM Gamma(log) modelo médio
  
  
#### Tempo de extinção na presença da residente
  
```{r graficos exploratorios TEI 2spp,echo=FALSE}
df_2sp <- read_csv(file="resultados/df_rep_tFinal.csv") |> 
  select(id,M0,C_nm,t,invasion) |> 
  mutate(TE = t/365.25,
         across(c(TE,M0),log,.names="log_{.col}"))
l_p <- list()
l_p[[1]] <- df_2sp |> 
  pivot_longer(cols=c("TE","log_TE"),names_to = "variaveis",values_to = "valores") |> 
  ggplot(aes(x=,y=valores)) +
  geom_density() +
  facet_wrap(~variaveis,scales="free") +
  coord_flip()
l_p[[2]] <- df_2sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=C_nm,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[3]] <- df_2sp |> 
  mutate(label = "escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
l_p[[4]] <- df_2sp |> 
  mutate(label = "escala log") |> 
  ggplot(aes(x=M0,y=log_TE)) +
  geom_point() +
  geom_smooth(method = "loess",formula = "y~x") +
  facet_wrap(~label)
grid.arrange(grobs=l_p,ncol=2,top="Tempo de Extinção total: sucesso e fracasso na substituição da espécie residente")
```
  
__Figura A9__ Gráficos exploratórios do Tempo de Extinção total: quando a substituição foi um sucesso ou fracasso    


__Tabela A7__ Seleção do modelo cheio para descrever o tempo de extinção total.  
  
  
```{r ajuste modelo cheio lm TEI 2spp 1 }
# dados
df_2sp <- read_csv(file="resultados/df_rep_tFinal.csv") |> 
  mutate(log_M0 = log(M0),
         TE = t/365.25) |> 
  select(id,TE,M0,log_M0,C_nm)
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_2sp$M0.z <- f_z(df_2sp$M0)
df_2sp$log_M0.z <- f_z(df_2sp$log_M0)
df_2sp$C_nm.z <- f_z(df_2sp$C_nm)
# modelos
l_md <- list()
l_md[[1]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[2]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[3]] <- glmer(TE ~ (M0.z + I(M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[4]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[5]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[6]] <- glmer(TE ~ (log_M0.z + I(log_M0.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[7]] <- glmer(TE ~ (C_nm.z + I(C_nm.z^2)) + (1|id),data = df_2sp, Gamma(log))
l_md[[8]] <- glmer(TE ~ 1 + (1|id),data = df_2sp, Gamma(log))
l_md[[9]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))*(M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[10]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[11]] <- glm(TE ~ (M0.z + I(M0.z^2)),data = df_2sp, Gamma(log))
l_md[[12]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))*(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[13]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[14]] <- glm(TE ~ (log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log))
l_md[[15]] <- glm(TE ~ (C_nm.z + I(C_nm.z^2)),data = df_2sp, Gamma(log))
l_md[[16]] <- glm(TE ~ 1,data = df_2sp, Gamma(log))
names(l_md) <- c("C_nm^2 * M0^2","C_nm^2 + M0^2","M0^2",
                 "C_nm^2 * log(M0)^2","C_nm^2 + log(M0)^2","log(M0)^2",
                 "C_nm^2","1",
                 "GLM:: C_nm^2 * M0^2","GLM::C_nm^2 + M0^2","GLM:: M0^2",
                 "GLM:: C_nm^2 * log(M0)^2","GLM:: C_nm^2 + log(M0)^2","GLM:: log(M0)^2",
                 "GLM:: C_nm^2","GLM:: 1")
AICctab(l_md,weights=TRUE)
```


__Tabela A8__ sumário do glmer Gamma(log) TEI 2spp cheio mais plausível: C_nm^2 + log(M0)^2  
  
```{r tabela A8}
summary(l_md[["C_nm^2 + log(M0)^2"]])
```



```{r residuos quantilicos lmer TEI 2spp}
res.Dharma <- DHARMa::simulateResiduals(l_md[["C_nm^2 + log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```

__Figura A10__ Resíduos quantílicos glmer Gamma(log) TEI 2spp cheio: C_nm^2 + log(M0)^2


```{r}
res.Dharma <- DHARMa::simulateResiduals(l_md[["GLM:: C_nm^2 + log(M0)^2"]],n = 250,refit = FALSE)
plot(res.Dharma)
```

__Figura A10__ Resíduos quantílicos glmer Gamma(log) TEI 2spp cheio: C_nm^2 + log(M0)^2

###### Modelo Médio


```{r}
# modelo referência
md_ref <- glm(TE ~ (C_nm.z + I(C_nm.z^2))+(log_M0.z + I(log_M0.z^2)),data = df_2sp, Gamma(log), na.action = "na.fail")
# todas as combinações do modelo cheio
registerDoMC(3)
l_dredge_nInvasions <- llply(dredge(md_ref,trace = FALSE,evaluate=FALSE), eval,.parallel = TRUE)
# model averaging prediction
v_gamma.shape = MASS::gamma.dispersion(md_ref)
df_AICcmodavg <- modavgPred(l_dredge_nInvasions,newdata = df_2sp,type="link",gamdisp=v_gamma.shape) %>%
  cbind(df_2sp) 
df_GLMGamma_modavg_2spp <- df_AICcmodavg |> 
  mutate(log_TE = log(TE)) |> 
  select(TE,log_TE,M0,log_M0,C_nm,mod.avg.pred,lower.CL,upper.CL) |>
  mutate(across(mod.avg.pred:upper.CL,exp,.names="{.col}_exp"))
write_csv(df_GLMGamma_modavg_2spp,file = "resultados/df_GLMGamma_modavg_2spp.csv")
```
```{r predito e observado df GLMGamma modavg 2spp}
df_AICcmodavg <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5))
l_p <- list()
l_p[[1]] <- df_AICcmodavg |> 
  ggplot(aes(x=log_M0,y=log_TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL,ymax=upper.CL),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred)) +
  labs(y="log(TE)",x="log(M0)") +
  facet_wrap(~C_nm,ncol=3)
l_p[[2]] <- df_AICcmodavg |> 
  mutate(label = "y e x: escala padrão") |> 
  ggplot(aes(x=M0,y=TE)) +
  geom_point() +
  geom_ribbon(aes(ymin=lower.CL_exp,ymax=upper.CL_exp),alpha=0.5,color="red",fill="red") +
  geom_line(aes(y=mod.avg.pred_exp)) +
  labs(y="TE (anos)",x="M0 (indivíduos)") +
  facet_wrap(~C_nm,ncol=3)
grid.arrange(grobs=l_p,ncol=1,top="Observado e Predito pelo GLM Gamma(log)")
```




######## projeto da figura

```{r figura 3b}
# preparação dos dados
## df_plot_2spp
df_plot_2spp <- read_csv("resultados/df_GLMGamma_modavg_2spp.csv") |> 
  filter(C_nm %in% c(-0.5,0,0.5), M0 %in% c(2,25,50)) |> 
  select(TE:M0,C_nm) |> mutate(C_nm = as.character(C_nm))
### df_plot_1spp
df_plot_1spp <- read_csv("resultados/df_GLMGamma_modavg_1sp.csv") |> 
  arrange(M0) |> 
  filter(M0 %in% unique(df_plot_2spp$M0)) |> 
  select(TE:M0) |> mutate(C_nm = "1sp")
### df_plot
df_plot <- rbind(df_plot_2spp,df_plot_1spp) |> 
  mutate(across(M0:C_nm,factor))
# gráficos
df_plot |> 
  ggplot(aes(x=TE)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  facet_grid(M0~C_nm,scales="free_y")
```

