---
title: "Generalization of the stochastic logistic model to interspecific competition"
author: "Danilo Pereira Mori"
date: "2022-08-20"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,message = FALSE,warning = FALSE,cache = TRUE)
```

```{r google docs management, eval=FALSE,include=FALSE}
library(trackdown)
# both overwrite: 
# to update:
upload_file(file ="relatorio_final.Rmd",
            gpath = "mestrado/disciplinas/BIE5716/",
            hide_code = TRUE)

```

# Introdução
O modelo de crescimento exponencial incorpora o princípio fundamental de que a vida provém de outra e assim examina o comportamento de uma população que pode crescer sem limitação alguma. Ao incluir a influência que o aumento na densidade populacional pode ter na limitação do crescimento, o modelo logístico incorpora outro princípio fundamental que é o da perda de excedente de indivíduos esperado por um crescimento ilimitado. Caso uma população crescesse de forma exponencial todo o universo conhecido poderia estar colonizado por um único tipo de vida. Outro componente essencial da modulação dos eventos demográficos é a interação com outras espécies. 
Aqui vamos explorar um modelo de competição de 2 populações em crescimento denso dependente, N e M. Vamos modelar o sistema usando um arcabouço de processos de difusão (Gillespie 1977) onde as reações individuais, microscópicas, são explicitadas com a intenção de descrever o comportamento macroscópico do sistema em termos do tamanho populacional das espécies. Os modelos de competição de populações em denso dependência do arcabouço de reações de difusão (estocásticos) diferem dos modelos baseados em taxas constantes (determinísticos), pois os eventos demográficos são representados como eventos probabilísticos que podem ou não ocorrer em intervalos de tempo muito pequenos. Dessa forma, os modelos estocásticos possibilitam eventos de extinção de populações que poderiam permanecer indefinidamente no predito determinístico; ou flutuações nos tamanhos populacionais, propriedade ausente nos modelos determinísticos de denso dependência linear. Os modelos estocásticos podem ser descritos por uma equação mestra, um conjunto de equações diferenciais de primeira ordem que descrevem como a probabilidade de todos os possíveis estados do sistema variam no tempo contínuo. A partir da equação mestra é possível calcular  a equação diferencial do primeiro momento da distribuição de probabilidades do sistema. Usando a aproximação de campo médio, onde é pressuposto variância zero, a equação diferencial do primeiro momento converge com a solução determinística. A abordagem alternativa ao uso da equação mestra, que descreve todos os estados do sistema, é simular possíveis trajetórias indivíduais do sistema implementando o algoritmo de Gillespie (1977). A ideia do algoritmo se baseia no fato de que a distribuição de tempos entre mudanças de estados pode ser descrita por uma distribuição exponencial, então computamos separadamente as mudanças de estado e o tempo entre mudanças, reduzindo o tempo de simulação. 
Com a intenção de avaliar se é possível ter alguma intuição sobre o comportamento do sistema estocástico a partir da aproximação de campo médio, me pergunto como o predito determinístico diverge do observado em uma série de simulações individuais do processo estocástico. Uma expectativa é que a probabilidade da espécie invasora substituir a espécie residente deve aumentar quanto maior o tamanho populacional inicial da invasora e maior a assimetria competitiva em favor da invasora. Pois, quanto menor o tamanho populacional maior a chance de uma sequência de eventos demográficos leve à extinção da invasora, mesmo quando dominante. E quanto maior a assimetria competitiva em favor da invasora, maior a probabilidade da espécie residente reduzir em abundância por possível evento demográfico.

## Reações  
  
Vamos modelar a mudança de estado do sistema, descrito por (n,m), onde n e m são a abundância de N e M, respectivamente. O modelo considera possíveis mudanças discretas de 1 indivíduo no sistema em um intervalo de tempo muito pequeno dt. As oito reações consideradas estão disponíveis na tabela 1, elas constituem um modelo de denso dependência em que a competição interespecífica é modelada de forma similar à da competição intraespecífica: pela probabilidade de exclusão de um dos dois indivíduos por evento de colisão de dois indivíduos. O modelo pressupõe que não é possível distinguir entre indivíduos de uma mesma espécie, assim, o parâmetro $\gamma$ descreve a probabilidade de qualquer um dos dois indivíduos ser excluído, por isso ele está dividido por 2.

```{r tabela 1}
library(knitr)
library(kableExtra)
df_tabela1 <- data.frame(reactions = c("n -> n + n","n -> 0","n + n -> n","n + m -> m",
                                       "m -> m + m","m -> 0","m + m -> m","m + n -> n"),
                         description = c("reprod. assex. de N","morte de N","comp. intraesp. de N","exclusão de N por M",
                                         "reprod. assex. de M","morte de M","comp. intraesp. de M","exclusão de M por N"),
                         Prob_dt = c("$\\beta n$","$\\delta n$","$\\gamma n (n-1) 2^{-1}$","$\\text{C}_{n} n m$",
                                     "$\\beta m$","$\\delta m$","$\\gamma m (m-1) 2^{-1}$","$\\text{C}_{m} m n$"),
                         unit_ParDemog = c("$P(nasc. de N)/ind. de N  dt$", "$P(morte de N)/ind. de N dt$",
                                           "$P(exclusão de N)/colisão N dt$","$P(exclusão de N)/colisão N M dt$",
                                           "$P(nasc. de M)/ind. de M dt$", "$P(morte de M)/ind. de M dt$",
                                           "$P(exclusão de M)/colisão M dt$","$P(exclusão de M)/colisão M N dt$"))
df_tabela1 %>%
  kbl(caption = "Tabela 1. Possíveis reações no modelo estocástico de competição de duas espécies sob denso dependência",
      col.names = c("reações","descrição","P(reação)/dt","unidade do parâmetro")) %>%
  kable_classic(full_width = T, html_font = "Cambria")

```
  
## The master equation and the mean-field approximation   
   
     
A partir das reações é possível desenvolver uma equação mestra que descreve a taxa de mudança da probabilidade de um determinado estado [$\frac{\partial P(n,m,t)}{\partial t}$] pela diferença na taxa da probabilidade de entrada e saída deste estado (equação 1). Na primeira linha depois da igualdade, há a soma das taxa com que N pode perder um indivíduo, indo do estado (n+1,m) para o estado (n,m). Na segunda linha a taxa com que N pode ganhar um indivíduo, indo do estado (n-1,m) para o estado (n,m). Nas linhas 3 e 4 a mesma lógica para M. Na quinta linha há a taxa de saída do estado (n,m). Para detalhes veja tabela 1.

$$
\frac{\partial P(n,m,t)}{\partial t} = \\
P(n+1,m) (n+1) (\delta_n + n \gamma_n / 2 + m C_{n}) +\\ P(n-1,m) (n-1) \beta_n+\\ 
P(n,m+1) (m+1) (\delta_m + m \gamma_m / 2 + n C_{m}) +\\ P(n,m-1) (m-1) \beta_m+\\
- P(n,m)[n(\beta_n + \delta_n + (n-1) \gamma_n / 2 + m C_{n}) + m(\beta_m + \delta_m + (m-1) \gamma_m / 2 + n C_{m})]
$$

Na aproximação de campo médio buscamos obter o primeiro momento da distribuição de probabilidade marginal de N, E[N] = <n>, e de M, E[M] = <m>. Para isso é necessário estabelecer algumas definições: $<n> = \sum_{n=0}^{\infty} n P(n,m,t)$; $<n^2> = \sum_{n=0}^{\infty} n^2 P(n,m,t)$; $<m> = \sum_{m=0}^{\infty} m P(n,m,t)$; $<m^2> = \sum_{m=0}^{\infty} m^2 P(n,m,t)$; $<nm> = \sum_{n=0}^{\infty}\sum_{m=0}^{\infty} nm P(n,m,t)$. Para obter o primeiro momento basta multiplicar a equação mestra por n ou m e realizar o somatório (apêndice 1), e então é possível obter as equações 2a e 2b:

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n^2>\gamma_n2^{-1} - <nm>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m^2>\gamma_m2^{-1} - <mn>C_m
$$

A aproximação de campo médio pressupõe que $<n>^2 = <n^2>$, $<m>^2 = <m^2>$, $<nm> = <n><m>$. Esse pressuposto implica que a variância da dinâmica populacional denso dependente é zero e que as populações são independentes. Outro pressuposto possível para simplificar a aproximação é de que $\beta$ ou $\delta$ >> $\gamma$, assim $\gamma$ pode ser omitido como fator do primeiro momento. Essa aproximação é útil pois permite a convergência das equações acima com o modelo determinístico de competição interespecífica de duas populações com crescimento denso dependente (eq. 3a e 3b). A investigação desse modelo determinístico mostra o quê poderíamos esperar no equilíbrio caso não houvesse nenhuma flutuação devido à estocástica dos eventos demográficos.

$$
\frac{d <n>}{d t} = <n> (\beta_n - \delta_n + \gamma_n2^{-1})- <n>^2\gamma_n2^{-1} - <n><m>C_n
$$
$$
\frac{d <m>}{d t} = <m> (\beta_m - \delta_m + \gamma_m2^{-1})- <m>^2\gamma_m2^{-1} - <m><n>C_m
$$
    
## Cenários de Assimetria Competitiva  
  
Para facilitar as análises vamos variar apenas o parâmetro que ajusta a probabilidade de exclusão de uma espécie pela outra por colisão (parâmetros $C_n$ e $C_m$, tabela 1). Os demais parâmetros populacionais serão iguais: $\beta =$ `r format(0.7/365.25,scientific = TRUE,digits = 4)`, $\delta =$ `r format(0.69/365.25,scientific = TRUE,digits = 4)`, $\gamma =$ `r format(2*(0.7/365.25-0.69/365.25)/50,scientific = TRUE,digits = 4)`. Os parâmetros de competição interespecífica ($C_n$ e $C_m$) variam entre $C_n = C_m = \gamma$ e $C_n = C_m = 2\gamma$, explorando dois extremos onde a espécie residente pode ser a espécie competitiva superior ou inferior. 

## The computational model

O tempo entre mudança de estados pode ser obtido pela divisão do log de uma amostra de distribuição uniforme padrão pela soma das taxas de saída do estado (janela de código 1). Existem 4 possíveis transições de estado: cada uma das duas espécies pode ganhar ou perder um indivíduo por evento demográfico no intervalo de tempo dt. A taxa de ganho de um indivíduo de N ($n\_p$) é  $n\_p=\beta n$. A taxa de perda de um indivíduo de N ($n\_m$) é $n\_m = n[\delta +(n-1)\gamma2^{-1} + mC_n]$. A mesma lógica se aplica para as taxas de ganho e perda da espécie M (eq. 1 e janela de código 1). Após o sorteio do tempo do próximo evento demográfico, é feito um sorteio da mudança de estado com probabilidade dada pela contribuição relativa de cada taxa de saída (janela de código 1), então o sistema é atualizado. Nossa simulação termina quando alguma população atinge o zero. 

__janela de código 1__

```{r the computacional model,echo=TRUE,eval=TRUE}
f_2sppSLV <- function(N0,beta_n,delta_n,gamma_n,C_n,
                      M0,beta_m,delta_m,gamma_m,C_m,
                      replicas,path_csv){
 df_ab <- data.frame(n=N0,m=M0,t=0)
 df_t <- data.frame(n=c(1,-1,0,0), # 4 possibles transitions:
                    m=c(0,0,1,-1)) # n + 1, n - 1, m + 1, m - 1
 f_loop <- function(){
   while(df_ab[nrow(df_ab),"n"]!=0 & df_ab[nrow(df_ab),"m"] !=0){
   v_rates <- c( 
     n_p = df_ab[nrow(df_ab),"n"] * beta_n,     # n+1
     n_m = df_ab[nrow(df_ab),"n"] * (delta_n +  # n-1
                                       (df_ab[nrow(df_ab),"n"]-1) * gamma_n/2 +
                                       C_n * df_ab[nrow(df_ab),"m"]),
     m_p = df_ab[nrow(df_ab),"m"] * beta_m,     # m+1
     m_m = df_ab[nrow(df_ab),"m"] *(delta_m +   # m-1
                                      (df_ab[nrow(df_ab),"m"]-1) * gamma_m/2 +  
                                      C_m * df_ab[nrow(df_ab),"n"]))
   v_Srates <- sum(v_rates)
   # update
   df_ab[nrow(df_ab)+1,] <- c(df_ab[nrow(df_ab),1:2] + df_t[sample(1:4,size = 1,prob=v_rates/v_Srates),],
                              df_ab[nrow(df_ab),"t"] - log(runif(1))/v_Srates)
   }
   return(df_ab)
}
df_dinamica <- plyr::rdply(.n = replicas,f_loop())
readr::write_csv(df_dinamica,file = path_csv)
}
```

```{r 2sppDLV, echo=FALSE,eval=FALSE,include=TRUE}
f_2sppDlv <- function(t,y,p){
  N <- y[1]
  M <- y[2]
  with(as.list(p),{
    dNdt <- (beta - delta)*N - gamma*(N^2)/2 - C_n*N*M
    dMdt <- (beta - delta)*M - gamma*(M^2)/2 - C_m*M*N
    return(list(c(dNdt,dMdt)))
  })
}
```

    
```{r desenho expercimental invasão, eval=FALSE,echo=FALSE}
# pacotes
library(deSolve)
library(plyr)
library(doMC)
library(tidyverse)
# dados
df_sim <- data.frame(k = 50, beta = 0.7/365.25, delta = 0.69/365.25) |> 
  mutate(gamma = 2* (beta - delta) / k)
df_sim <- cbind(df_sim,
                expand.grid(M0 = floor(df_sim$k * c(0.05,seq(0.2,1,by=0.2))), # 
                            C_n = df_sim$gamma * seq(1,2,length.out=6))) |> 
  mutate(C_m = gamma)
df_sim <- rbind(filter(df_sim,C_n!=df_sim$gamma[1]),
                mutate(df_sim,
                       C_m=C_n,C_n=gamma)) |> 
  mutate(id = 1:n(),
         path = paste0("csv/id_",id,".csv"))
df_sim2 <- df_sim |> select(!path)
df_sim2[,c(2:4,6:7)] <- apply(df_sim2[,c(2:4,6:7)],2,function(x) x*365.25)  

df_sim |> 
  mutate(M0_plot = M0/50,
         C_n.m = C_n - C_m,
         C_n.m_plot = C_n.m/gamma) |> 
  ggplot(aes(x=M0_plot,y=C_n.m_plot)) + 
  geom_hline(yintercept = 0,color="red",alpha=0.4) +
  geom_point() +
  labs(title = "Cenários Simulados",
       x="initial abundance m (%K = 50)",y=expression(C[n] - C[m]*"(%)"),
       subtitle = "n = resident specie, m = invader specie") +
  theme_bw()
```
  
__Figura 1__ Cenários simulados de competição interespecífica.  Eixo x: diferença no parâmetro C da espécie residente pela invasora, dividido pelo parâmetro $\gamma$.

```{r simulação do modelo nos cenários explorados, eval=FALSE,echo=FALSE,include=TRUE}
registerDoMC(3)
plyr::a_ply(df_sim,1,
            function(X) do.call("f_2sppSLV",
                                list(N0=X$k,beta_n=X$beta,delta_n=X$delta,gamma_n=X$gamma,C_n=X$C_n,
                                     M0=X$M0,beta_m=X$beta,delta_m=X$delta,gamma_m=X$gamma,C_m=X$C_m,
                                     replicas=50,path_csv=X$path)),
            .parallel = TRUE)
```





```{r simulacao do modelo deterministico}
f_2sppDLV <- function(X,max_t,int_t){
 f_ode<- function(t,y,p){
   N <- y[1]
   M <- y[2]
   with(as.list(p),{
     dNdt <- (beta - delta)*N - gamma*(N^2)/2 - C_n*N*M
     dMdt <- (beta - delta)*M - gamma*(M^2)/2 - C_m*M*Nreturn(list(c(dNdt,dMdt)))
   })
   }
 p <- unlist(select(X,beta:gamma,C_n:C_m))
 y0 <- unlist(X[,c("k","M0")])
 names(y0) <- c("N","M")
 times <- seq(0,max_t,int_t)
 df_ab.det <- ode(y=y0,times = times,func = f_2sppDlv,parms = p)
 return(df_ab.det)
}
#
df_resultados <- read_csv(file = "resultados/df_resultados.csv") |> 
  mutate(t_max_anos = t_max/365.25)
df_resultados$t_max_anos |> summary()
#
df_sim2 |> names
df_resultsDeterministicos <- adply(df_sim2,1,function(df) do.call("f_2sppDLV",X=df,max_t=400,int_t=0.05)  )
```



### anaĺise dos dados

```{r análises preparatórias, eval=FALSE, echo=FALSE, include=FALSE}
f_resultados <- function(X){
  read_csv(X$path) |>
    group_by(.n) |>
    slice_tail(n=1) |> 
    mutate(invasion=ifelse(m!=0,1,0))
}
registerDoMC(2)
df_rep.tFinal <- adply(df_sim,1,f_resultados,.parallel = TRUE)
df_resultados <- df_rep.tFinal |> 
  group_by(id) |>
  summarise(c_invasion = sum(invasion),
            t_mean = mean(t),
            t_var = var(t),
            t_max = max(t),
            n_mean = mean(n),
            n_var = var(n),
            m_mean = mean(m),
            m_var = var(m)) |> 
  inner_join(distinct(select(df_rep.tFinal,id:C_n)),by="id") |> 
  mutate(C_nm = (C_n - C_m)/df_sim$gamma[1]) |> 
  arrange(C_nm)
#
write_csv(df_rep.tFinal,file = "resultados/df_rep_tFinal.csv")
write_csv(df_resultados,file="resultados/df_resultados.csv")
```

```{r modelo estatístico para descrever a probabilidade de invasao,echo=FALSE,include=FALSE,eval=FALSE}
# pacote adicional
library(mgcv)
# dados para o modelo estatístico
df_resultados <- read_csv("resultados/df_resultados.csv")
f_z <- function(x){
  m <- base::mean(x,na.rm=FALSE)
  sd <- sd(x,na.rm=FALSE)
  output <- (x-m)/sd
  return(output)
} 
df_resultados$M0.z <- f_z(df_resultados$M0)
df_resultados$C_nm.z <- f_z(df_resultados$C_nm)
# glm binomial
md_P.replacement <- gam(cbind(c_invasion,50-c_invasion) ~ s(M0.z,bs = "cr") + s(C_nm.z,bs = "cr") + ti(M0.z,C_nm.z,bs=c("cr","cr")),
                        family = binomial(link = logit),data = df_resultados)
summary(md_P.replacement)
```
```{r graf exp prob replace the resident, echo=FALSE,include=TRUE,eval=TRUE}
library(tidyverse)
df_resultados <- readr::read_csv("resultados/df_resultados.csv")
df_resultados |> 
  mutate(Prob_invasion = c_invasion/50,
         propM0 = M0/50) |> 
  ggplot(aes(x=propM0,y=C_nm,fill=Prob_invasion)) +
  geom_tile() +
  scale_fill_distiller(palette = "Spectral") +
  labs(fill="",x="M0, initial pop. size of invader (%K)",y="Cn - Cm (%)") +
  coord_cartesian(expand = FALSE) +
  # scale_y_continuous(breaks = seq(0,20,by=4)) +
  # scale_x_continuous(breaks = seq(0.05,0.95,by=0.10)) +
  ggtitle("Prob(replace the resident specie)") +
  theme_classic()
```

# Apêndice

```{r time estimative, include=FALSE,echo=FALSE,eval=FALSE}
f_2sppSLV(N0=50, beta_n = 0.7/365.25, delta_n = 0.69/365.25, gamma_n = (0.7/365.25 - 0.69/365.25)/50, C_n =  (0.7/365.25 - 0.69/365.25)/50,
          M0=50, beta_m = 0.7/365.25, delta_m = 0.69/365.25, gamma_m = (0.7/365.25 - 0.69/365.25)/50, C_m =  (0.7/365.25 - 0.69/365.25)/50,replicas = 50)
start_time <- Sys.time()
plyr::rdply(.n = 2,f_loop())
end_time <- Sys.time()
end_time - start_time
```
